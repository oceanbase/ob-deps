diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1432432..5df2489 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -38,8 +38,8 @@ option (ENABLE_TSAN "Whether to turn Thread Sanitizer ON or OFF" OFF)
 option (ENABLE_FRAME_POINTER "Whether to build with -fno-omit-frame-pointer" ON)
 option (ENABLE_THIN_LTO "Whether to build with thin lto -flto=thin" OFF)
 option (ENABLE_CCACHE "Whether to open ccache" OFF)
-option (ENABLE_INTEL_MKL "Enable intel-mkl (x86 platform only)" ON)
-option (ENABLE_CXX11_ABI "Use CXX11 ABI" ON)
+option (ENABLE_INTEL_MKL "Enable intel-mkl (x86 platform only)" OFF)
+option (ENABLE_CXX11_ABI "Use CXX11 ABI" OFF)
 option (ENABLE_LIBCXX "Use libc++ instead of libstdc++" OFF) # only support in clang
 option (ENABLE_TOOLS "Whether compile vsag tools" ON)
 option (ENABLE_EXAMPLES "Whether compile examples" ON)
@@ -49,6 +49,8 @@ option (DISABLE_AVX_FORCE "Force disable avx and higher instructions" OFF)
 option (DISABLE_AVX2_FORCE "Force disable avx2 and higher instructions" OFF)
 option (DISABLE_AVX512_FORCE "Force disable avx512 instructions" OFF)
 
+set (ROARING_DISABLE_AVX512 ON)
+set (ENABLE_PYBINDS ON)
 
 if (ENABLE_CXX11_ABI)
     add_definitions (-D_GLIBCXX_USE_CXX11_ABI=1)
@@ -308,3 +310,32 @@ add_custom_target (version
         -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/GenerateVersionHeader.cmake
 )
 add_dependencies (vsag version)
+
+# set path
+set(VSAG_BASE_DIR ${CMAKE_BINARY_DIR})
+set(VSAG_LIB_DIR ${VSAG_BASE_DIR}/_deps)
+
+# Create shared library
+add_library(ob_vsag SHARED ob_vsag_lib.cpp)
+target_compile_options(ob_vsag PRIVATE -std=c++17)
+target_include_directories(ob_vsag PRIVATE
+                           ${VSAG_BASE_DIR}/include
+                           ${VSAG_LIB_DIR}/nlohmann_json-src/include
+                           ${VSAG_LIB_DIR}/roaringbitmap-src/include
+                           ${VSAG_LIB_DIR}/fmt-src/include)
+target_compile_definitions(ob_vsag PRIVATE _GLIBCXX_USE_CXX11_ABI=0)
+target_link_libraries(ob_vsag PUBLIC vsag_static -static-libstdc++ -static-libgcc)
+add_dependencies(ob_vsag vsag_static)
+
+# Create static library
+add_library(ob_vsag_static STATIC ob_vsag_lib.cpp)
+target_compile_options(ob_vsag_static PRIVATE -std=c++17)
+target_compile_definitions(ob_vsag_static PUBLIC _GLIBCXX_USE_CXX11_ABI=0)
+target_include_directories(ob_vsag_static PUBLIC
+                           ${VSAG_BASE_DIR}/include
+                           ${VSAG_LIB_DIR}/nlohmann_json-src/include
+                           ${VSAG_LIB_DIR}/roaringbitmap-src/include
+                           ${VSAG_LIB_DIR}/fmt-src/include)
+add_dependencies(ob_vsag vsag_static)
+
+add_subdirectory (example)
\ No newline at end of file
diff --git a/default_logger.h b/default_logger.h
new file mode 100644
index 0000000..6ec885d
--- /dev/null
+++ b/default_logger.h
@@ -0,0 +1,119 @@
+#ifndef DEFAULT_LOGGER_H
+#define DEFAULT_LOGGER_H
+
+#include "vsag/logger.h"
+#include "vsag/options.h"
+#include "fmt/format.h"
+
+namespace vsag {
+namespace logger {
+
+enum class level {
+    trace = Logger::Level::kTRACE,
+    debug = Logger::Level::kDEBUG,
+    info = Logger::Level::kINFO,
+    warn = Logger::Level::kWARN,
+    err = Logger::Level::kERR,
+    critical = Logger::Level::kCRITICAL,
+    off = Logger::Level::kOFF
+};
+
+class ObDefaultLogger : public Logger {
+public:
+    void
+    SetLevel(Logger::Level log_level) override;
+
+    void
+    Trace(const std::string& msg) override;
+
+    void
+    Debug(const std::string& msg) override;
+
+    void
+    Info(const std::string& msg) override;
+
+    void
+    Warn(const std::string& msg) override;
+
+    void
+    Error(const std::string& msg) override;
+
+    void
+    Critical(const std::string& msg) override;
+};
+
+
+inline void
+set_level(level log_level) {
+    Options::Instance().logger()->SetLevel((Logger::Level)log_level);
+}
+
+inline void
+trace(const std::string& msg) {
+    Options::Instance().logger()->Trace(msg);
+}
+
+inline void
+debug(const std::string& msg) {
+    Options::Instance().logger()->Debug(msg);
+}
+
+inline void
+info(const std::string& msg) {
+    Options::Instance().logger()->Info(msg);
+}
+
+inline void
+warn(const std::string& msg) {
+    Options::Instance().logger()->Warn(msg);
+}
+
+inline void
+error(const std::string& msg) {
+    Options::Instance().logger()->Error(msg);
+}
+
+inline void
+critical(const std::string& msg) {
+    Options::Instance().logger()->Critical(msg);
+}
+
+template <typename... Args>
+inline void
+trace(fmt::format_string<Args...> fmt, Args&&... args) {
+    trace(fmt::format(fmt, std::forward<Args>(args)...));
+}
+
+template <typename... Args>
+inline void
+debug(fmt::format_string<Args...> fmt, Args&&... args) {
+    debug(fmt::format(fmt, std::forward<Args>(args)...));
+}
+
+template <typename... Args>
+inline void
+info(fmt::format_string<Args...> fmt, Args&&... args) {
+    info(fmt::format(fmt, std::forward<Args>(args)...));
+}
+
+template <typename... Args>
+inline void
+warn(fmt::format_string<Args...> fmt, Args&&... args) {
+    warn(fmt::format(fmt, std::forward<Args>(args)...));
+}
+
+template <typename... Args>
+inline void
+error(fmt::format_string<Args...> fmt, Args&&... args) {
+    error(fmt::format(fmt, std::forward<Args>(args)...));
+}
+
+template <typename... Args>
+inline void
+critical(fmt::format_string<Args...> fmt, Args&&... args) {
+    critical(fmt::format(fmt, std::forward<Args>(args)...));
+}
+
+}  // namespace logger
+}  // namespace vsag
+#endif //DEFAULT_LOGGER_H
diff --git a/example/CMakeLists.txt b/example/CMakeLists.txt
new file mode 100644
index 0000000..0629034
--- /dev/null
+++ b/example/CMakeLists.txt
@@ -0,0 +1,4 @@
+add_executable(hnsw_example hnsw_example.cpp default_allocator.cpp)
+target_compile_options(hnsw_example PRIVATE -std=c++17)
+target_link_libraries(hnsw_example PRIVATE ob_vsag_static vsag dl roaring fmt)
+target_include_directories(hnsw_example BEFORE PRIVATE ${VSAG_LIB_DIR}/_deps/roaringbitmap-src/include/)
diff --git a/example/default_allocator.cpp b/example/default_allocator.cpp
new file mode 100644
index 0000000..44bf49f
--- /dev/null
+++ b/example/default_allocator.cpp
@@ -0,0 +1,60 @@
+#include "default_allocator.h"
+
+#include "vsag/options.h"
+#include "../default_logger.h"
+#include <stdio.h>
+
+#include <stdlib.h>
+#include <unistd.h>
+void *_malloc(size_t size, const char *filename, int line){
+    void *ptr = malloc(size);
+    
+    char buffer[128] = {0};
+    sprintf(buffer, "./%p.memory", ptr);
+
+    FILE *fp = fopen(buffer, "w");
+    fprintf(fp, "[+]addr: %p, filename: %s, line: %d\n", ptr, filename, line);
+
+    fflush(fp);
+    fclose(fp);
+
+    return ptr;
+}
+
+void _free(void *ptr, const char *filename, int line){
+    char buffer[1280] = {0};
+    sprintf(buffer, "./memory/%p.memory", ptr);
+
+    if (unlink(buffer) < 0){
+        printf("double free: %p\n", ptr);
+        return;
+    }
+
+    return free(ptr);
+}
+//#define malloc(size)    _malloc(size, __FILE__, __LINE__)
+//#define free(ptr)       _free(ptr, __FILE__, __LINE__)
+void*
+DefaultAllocator::Allocate(size_t size) {
+    void* ptr = malloc(size);
+    //vsag::logger::debug("allocate memoery,addr:{}, size:{}",ptr, size);
+    return malloc(size);
+}
+
+void
+DefaultAllocator::Deallocate(void* p) {
+    //vsag::logger::debug("free memoery, alloctor:{}, free_addr:{}", (void*)this, p);
+    free(p);
+}
+
+void*
+DefaultAllocator::Reallocate(void* p, size_t size) {
+    //vsag::logger::debug("re-allocate memoery,addr:{}, size:{}",p,size);
+    return realloc(p, size);
+}
+
+std::string
+DefaultAllocator::Name() {
+    return "DefaultAllocator";
+}
+
diff --git a/example/default_allocator.h b/example/default_allocator.h
new file mode 100644
index 0000000..9d26252
--- /dev/null
+++ b/example/default_allocator.h
@@ -0,0 +1,26 @@
+#ifndef DEFAULT_ALLOCATOR_H
+#define DEFAULT_ALLOCATOR_H
+#include "vsag/allocator.h"
+
+class DefaultAllocator : public vsag::Allocator {
+public:
+    DefaultAllocator() = default;
+    virtual ~DefaultAllocator() = default;
+
+    DefaultAllocator(const DefaultAllocator&) = delete;
+    DefaultAllocator(DefaultAllocator&&) = delete;
+
+public:
+    std::string
+    Name() override;
+
+    void*
+    Allocate(size_t size) override;
+
+    void
+    Deallocate(void* p) override;
+
+    void*
+    Reallocate(void* p, size_t size) override;
+};
+#endif // DEFAULT_ALLOCATOR_H
diff --git a/example/hnsw_example.cpp b/example/hnsw_example.cpp
new file mode 100644
index 0000000..cb95252
--- /dev/null
+++ b/example/hnsw_example.cpp
@@ -0,0 +1,763 @@
+#include "../ob_vsag_lib.h"
+#include "default_allocator.h"
+#include <random>
+#include <dlfcn.h>
+#include "../ob_vsag_lib_c.h"
+#include <iostream>
+#include "../default_logger.h"
+#include "roaring/roaring64.h"
+#include "vsag/iterator_context.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+class TestFilter : public obvectorlib::FilterInterface
+{
+public:
+    TestFilter(roaring::api::roaring64_bitmap_t *bitmap) : bitmap_(bitmap) {}
+    ~TestFilter() {}
+    bool test(int64_t id) override { return roaring::api::roaring64_bitmap_contains(bitmap_, id); }
+    bool test(const char* data) override { return true; }
+public:
+    roaring::api::roaring64_bitmap_t* bitmap_;
+};
+
+int64_t example() {
+    std::cout<<"test hnsw_example: "<<std::endl;
+    bool is_init = obvectorlib::is_init();
+    //set_log_level(1);
+    obvectorlib::VectorIndexPtr index_handler = NULL;
+    int dim = 1536;
+    int max_degree = 16;
+    int ef_search = 200;
+    int ef_construction = 100;
+    DefaultAllocator default_allocator;
+    const char* const METRIC_L2 = "l2";
+    const char* const METRIC_IP = "ip";
+
+    const char* const DATATYPE_FLOAT32 = "float32";
+    void * test_ptr = default_allocator.Allocate(10);
+    int ret_create_index = obvectorlib::create_index(index_handler,
+                                                     obvectorlib::HNSW_TYPE,
+                                                     DATATYPE_FLOAT32,
+                                                     METRIC_L2,
+                                                     dim,
+                                                     max_degree,
+                                                     ef_construction,
+                                                     ef_search,
+                                                     &default_allocator);
+   
+    if (ret_create_index!=0) return 333;
+    int num_vectors = 10000;
+    auto ids = new int64_t[num_vectors];
+    auto vectors = new float[dim * num_vectors];
+    std::mt19937 rng;
+    rng.seed(47);
+    std::uniform_real_distribution<> distrib_real;
+    for (int64_t i = 0; i < num_vectors; ++i) {
+        ids[i] = i;
+    }
+    for (int64_t i = 0; i < dim * num_vectors; ++i) {
+        vectors[i] = distrib_real(rng);
+    }
+    int ret_build_index = obvectorlib::build_index(index_handler, vectors, ids, dim, num_vectors);
+
+    int64_t num_size = 0;
+    int ret_get_element = obvectorlib::get_index_number(index_handler, num_size);
+    std::cout<<"after add index, size is "<<num_size<<" " <<ret_get_element<<std::endl;
+
+    int inc_num = 10000;
+    auto inc = new float[dim * inc_num];
+    for (int64_t i = 0; i < dim * inc_num; ++i) {
+        inc[i] = distrib_real(rng);
+    }
+    auto ids2 = new int64_t[inc_num];
+    for (int64_t i = 0; i < inc_num; ++i) {
+        ids2[i] = i + num_vectors;
+    }
+ 
+    int ret_add_index = obvectorlib::add_index(index_handler, inc, ids2, dim,inc_num);
+    ret_get_element = obvectorlib::get_index_number(index_handler, num_size);
+    std::cout<<"after add index, size is "<<num_size<<" " <<ret_add_index<<std::endl;
+    
+    const float* result_dist;
+    const int64_t* result_ids;
+    int64_t result_size = 0;
+
+    roaring::api::roaring64_bitmap_t* r1 = roaring::api::roaring64_bitmap_create();
+    TestFilter testfilter(r1);
+    const char *extra_info = nullptr;
+    int ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist,result_ids,result_size, 
+                                                 100, false/*need_extra_info*/, extra_info, &testfilter, false, false, 1);
+    
+    roaring64_bitmap_add_range(r1, 0, 19800);
+
+    ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist,result_ids,result_size, 
+                                                 100, false/*need_extra_info*/, extra_info, &testfilter, false, false, 0.01);
+    const float *distances;
+    // ret_knn_search = obvectorlib::cal_distance_by_id(index_handler, vectors+dim*(num_vectors-1), result_ids, result_size, distances);
+    for (int i = 0; i < result_size; i++) {
+        std::cout << "result: " << result_ids[i] << " " << result_dist[i] << std::endl;
+        // std::cout << "calres: " << result_ids[i] << " " << distances[i] << std::endl;
+    }
+    obvectorlib::delete_index(index_handler);
+    free(test_ptr);
+    return 0;
+}
+
+void
+vsag::logger::ObDefaultLogger::SetLevel(Logger::Level log_level) {
+    //
+}
+
+void
+vsag::logger::ObDefaultLogger::Trace(const std::string& msg) {
+    //
+}
+
+void
+vsag::logger::ObDefaultLogger::Debug(const std::string& msg) {
+    //
+}
+
+void
+vsag::logger::ObDefaultLogger::Info(const std::string& msg) {
+    //
+}
+
+void
+vsag::logger::ObDefaultLogger::Warn(const std::string& msg) {
+    //
+}
+
+void
+vsag::logger::ObDefaultLogger::Error(const std::string& msg) {
+    //
+}
+
+void
+vsag::logger::ObDefaultLogger::Critical(const std::string& msg) {
+    //
+}
+
+int example_so() {
+    std::cout<<"test hnsw_example with dlopen: "<<std::endl;
+    // Path to the dynamic library
+    const char* lib_path = "./libob_vsag.so";  // Linux
+    // const char* lib_path = "libexample.dylib";  // macOS
+
+    // Open the dynamic library
+    void* handle = dlopen(lib_path, RTLD_LAZY);
+    if (!handle) {
+        fprintf(stderr, "%s\n", dlerror());
+        return EXIT_FAILURE;
+    }
+    
+
+    obvectorlib::set_logger_ptr set_logger_c;
+    LOAD_FUNCTION(handle, obvectorlib::set_logger_ptr, set_logger_c);
+    //void* raw_memory = (void*)malloc(sizeof( vsag::logger::ObDefaultLogger));
+    //vsag::logger::ObDefaultLogger* ob_logger = new (raw_memory)vsag::logger::ObDefaultLogger();
+    //vsag::logger::ObDefaultLogger* ob_logger = new vsag::logger::ObDefaultLogger();
+    //set_logger_c(ob_logger);
+
+    //init
+    //obvectorlib::is_init_ptr is_init_c;
+    //LOAD_FUNCTION(handle, obvectorlib::is_init_ptr, is_init_c);
+    //bool is_vsag_init_ = is_init_c();
+    //std::cout << "is_vsag_init_: " << is_vsag_init_ << std::endl;
+
+    //create index
+    obvectorlib::create_index_ptr create_index_c;
+    LOAD_FUNCTION(handle, obvectorlib::create_index_ptr, create_index_c);
+    obvectorlib::VectorIndexPtr index_handler = NULL;
+    int dim = 128;
+    int max_degree = 16;
+    int ef_search = 200;
+    int ef_construction = 100;
+    DefaultAllocator default_allocator;
+    const char* const METRIC_L2 = "l2";
+    const char* const DATATYPE_FLOAT32 = "float32";
+    int ret_create_index = create_index_c(index_handler,
+                                                     obvectorlib::HNSW_TYPE,
+                                                     DATATYPE_FLOAT32,
+                                                     METRIC_L2,
+                                                     dim,
+                                                     max_degree,
+                                                     ef_construction,
+                                                     ef_search,
+                                                     &default_allocator);
+
+    //build index
+    obvectorlib::build_index_ptr build_index_c;
+    LOAD_FUNCTION(handle, obvectorlib::build_index_ptr, build_index_c);
+    obvectorlib::get_index_number_ptr get_index_number_c;
+    LOAD_FUNCTION(handle, obvectorlib::get_index_number_ptr, get_index_number_c);
+    int num_vectors = 10000;
+    auto ids = new int64_t[num_vectors];
+    auto vectors = new float[dim * num_vectors];
+    std::mt19937 rng;
+    rng.seed(47);
+    std::uniform_real_distribution<> distrib_real;
+    for (int64_t i = 0; i < num_vectors; ++i) {
+        ids[i] = i;
+    }
+    for (int64_t i = 0; i < dim * num_vectors; ++i) {
+        vectors[i] = distrib_real(rng);
+    }
+    int ret_build_index = build_index_c(index_handler, vectors, ids, dim, num_vectors);
+    
+    int64_t num_size = 0;
+    int ret_get_element = get_index_number_c(index_handler, num_size);
+
+    //add index
+    obvectorlib::add_index_ptr add_index_c;
+    LOAD_FUNCTION(handle, obvectorlib::add_index_ptr, add_index_c);
+    int inc_num = 10000;
+    auto inc = new float[dim * inc_num];
+    for (int64_t i = 0; i < dim * inc_num; ++i) {
+        inc[i] = distrib_real(rng);
+    }
+    auto ids2 = new int64_t[inc_num];
+    for (int64_t i = 0; i < inc_num; ++i) {
+        ids2[i] = num_size+i;
+    }
+    
+    int ret_add_index = add_index_c(index_handler, inc, ids2, dim,inc_num);
+    ret_get_element = get_index_number_c(index_handler, num_size);
+    
+    //knn_search
+    obvectorlib::knn_search_ptr knn_search_c;
+    LOAD_FUNCTION(handle, obvectorlib::knn_search_ptr, knn_search_c);
+    const float* result_dist;
+    const int64_t* result_ids;
+    int64_t result_size = 0;
+
+    roaring::api::roaring64_bitmap_t* r1 = roaring::api::roaring64_bitmap_create();
+
+    roaring::api::roaring64_bitmap_add(r1, 9999);
+    roaring::api::roaring64_bitmap_add(r1, 1169);
+    roaring::api::roaring64_bitmap_add(r1, 1285);
+
+    int ret_knn_search = knn_search_c(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist,result_ids,result_size, 
+                                                 100, r1, false);
+
+    //serialize/deserialize
+    obvectorlib::serialize_ptr serialize_c;
+    LOAD_FUNCTION(handle, obvectorlib::serialize_ptr, serialize_c);
+    obvectorlib::deserialize_bin_ptr deserialize_bin_c;
+    LOAD_FUNCTION(handle, obvectorlib::deserialize_bin_ptr, deserialize_bin_c);
+    const std::string dir = "./";
+    int ret_serialize_single = serialize_c(index_handler,dir);
+    int ret_deserilize_single_bin = deserialize_bin_c(index_handler,dir);
+    obvectorlib::delete_index_c(index_handler);
+
+    // Clean up
+    dlclose(handle);
+    
+    return 0;
+}
+
+int64_t hnswsq_example() {
+    std::cout<<"test hnswsq_example: "<<std::endl;
+    bool is_init = obvectorlib::is_init();
+    obvectorlib::VectorIndexPtr index_handler = NULL;
+    int dim = 128;
+    int max_degree = 16;
+    int ef_search = 200;
+    int ef_construction = 100;
+    DefaultAllocator default_allocator;
+    const char* const METRIC_L2 = "l2";
+    const char* const METRIC_IP = "ip";
+
+    const char* const DATATYPE_FLOAT32 = "float32";
+    void * test_ptr = default_allocator.Allocate(10);
+    int ret_create_index = obvectorlib::create_index(index_handler,
+                                                     obvectorlib::HNSW_SQ_TYPE,
+                                                     DATATYPE_FLOAT32,
+                                                     METRIC_L2,
+                                                     dim,
+                                                     max_degree,
+                                                     ef_construction,
+                                                     ef_search,
+                                                     &default_allocator);
+   
+    if (ret_create_index!=0) return 333;
+    int num_vectors = 10000;
+    auto ids = new int64_t[num_vectors];
+    auto vectors = new float[dim * num_vectors];
+    std::mt19937 rng;
+    rng.seed(47);
+    std::uniform_real_distribution<> distrib_real;
+    for (int64_t i = 0; i < num_vectors; ++i) {
+        ids[i] = i + num_vectors*10;
+    }
+    for (int64_t i = 0; i < dim * num_vectors; ++i) {
+        vectors[i] = distrib_real(rng);
+    }
+    int ret_build_index = obvectorlib::build_index(index_handler, vectors, ids, dim, num_vectors);
+
+    int64_t num_size = 0;
+    int ret_get_element = obvectorlib::get_index_number(index_handler, num_size);
+    std::cout<<"after add index, size is "<<num_size<<" " <<ret_get_element<<std::endl;
+    
+    const float* result_dist;
+    const int64_t* result_ids;
+    int64_t result_size = 0;
+    auto query_vector = new float[dim];
+    for (int64_t i = 0; i < dim; ++i) {
+        query_vector[i] = distrib_real(rng);
+    }
+
+    roaring::api::roaring64_bitmap_t* r1 = roaring::api::roaring64_bitmap_create();
+
+    roaring::api::roaring64_bitmap_add(r1, 18);
+    roaring::api::roaring64_bitmap_add(r1, 1169);
+    roaring::api::roaring64_bitmap_add(r1, 1285);
+    std::cout << "before search" << std::endl;
+    TestFilter testfilter(r1);
+    const char *extra_info = nullptr;
+    int ret_knn_search = obvectorlib::knn_search(index_handler, query_vector, dim, 10,
+                                                 result_dist,result_ids,result_size, 
+                                                 100, false/*need_extra_info*/, extra_info, &testfilter);
+    
+    for (int i = 0; i < result_size; i++) {
+        std::cout << "result: " << result_ids[i] << " " << result_dist[i] << std::endl;
+    }
+    int inc_num = 1000;
+    auto inc = new float[dim * inc_num];
+    for (int64_t i = 0; i < dim * inc_num; ++i) {
+        inc[i] = distrib_real(rng);
+    }
+    auto ids2 = new int64_t[inc_num];
+    for (int64_t i = 0; i < inc_num; ++i) {
+        ids2[i] = i + num_vectors*100;
+    }
+
+    // const std::string dir = "./";
+    // int ret_serialize_single = obvectorlib::serialize(index_handler,dir);
+    // int ret_deserilize_single_bin = 
+    //                 obvectorlib::deserialize_bin(index_handler,dir);
+    // ret_knn_search = obvectorlib::knn_search(index_handler, query_vector, dim, 10,
+    //                                              result_dist,result_ids,result_size, 
+    //                                              100, r1);
+    // for (int i = 0; i < result_size; i++) {
+    //     std::cout << "result: " << result_ids[i] << " " << result_dist[i] << std::endl;
+    // }
+    obvectorlib::delete_index(index_handler);
+    free(test_ptr);
+    return 0;
+}
+
+int64_t example_extra_info() {
+    std::cout<<"test example_extra_info example: "<<std::endl;
+    bool is_init = obvectorlib::is_init();
+    //set_log_level(1);
+    obvectorlib::VectorIndexPtr index_handler = NULL;
+    int dim = 1536;
+    int max_degree = 16;
+    int ef_search = 200;
+    int ef_construction = 100;
+    DefaultAllocator default_allocator;
+    const char* const METRIC_L2 = "l2";
+    const char* const METRIC_IP = "ip";
+
+    const char* const DATATYPE_FLOAT32 = "float32";
+    void * test_ptr = default_allocator.Allocate(10);
+    int extra_info_sz = 32;
+    std::cout<<"test create_index: "<<std::endl;
+    int ret_create_index = obvectorlib::create_index(index_handler,
+                                                     obvectorlib::HGRAPH_TYPE,
+                                                     DATATYPE_FLOAT32,
+                                                     METRIC_L2,
+                                                     dim,
+                                                     max_degree,
+                                                     ef_construction,
+                                                     ef_search,
+                                                     &default_allocator,
+                                                     extra_info_sz);
+
+    if (ret_create_index!=0) return 333;
+    int num_vectors = 10000;
+    auto ids = new int64_t[num_vectors];
+    auto vectors = new float[dim * num_vectors];
+    std::mt19937 rng;
+    rng.seed(47);
+    std::uniform_real_distribution<> distrib_real;
+    for (int64_t i = 0; i < num_vectors; ++i) {
+        ids[i] = i;
+    }
+    for (int64_t i = 0; i < dim * num_vectors; ++i) {
+        vectors[i] = distrib_real(rng);
+    }
+    std::cout<<"test build_index: "<<std::endl;
+    char extra_infos[extra_info_sz * num_vectors];
+    for (int i = 0; i < extra_info_sz * num_vectors; i++) {
+        extra_infos[i] = rand() % 9 + '0';
+    }
+    int ret_build_index = obvectorlib::build_index(index_handler, vectors, ids, dim, num_vectors, extra_infos);
+
+    int64_t num_size = 0;
+    std::cout<<"test get_index_number: "<<std::endl;
+    int ret_get_element = obvectorlib::get_index_number(index_handler, num_size);
+    std::cout<<"after add index, size is "<<num_size<<" " <<ret_get_element<<std::endl;
+
+    int inc_num = 10000;
+    auto inc = new float[dim * inc_num];
+    for (int64_t i = 0; i < dim * inc_num; ++i) {
+        inc[i] = distrib_real(rng);
+    }
+    auto ids2 = new int64_t[inc_num];
+    for (int64_t i = 0; i < inc_num; ++i) {
+        ids2[i] = i + num_vectors;
+    }
+
+    std::cout<<"test add_index: "<<std::endl;
+    char extra_info[extra_info_sz];
+    for (int i = 0; i < extra_info_sz; i++) {
+        extra_info[i] = rand() % 9 + '0';
+    }
+    int ret_add_index = obvectorlib::add_index(index_handler, inc, ids2, dim,inc_num, extra_info);
+    ret_get_element = obvectorlib::get_index_number(index_handler, num_size);
+    std::cout<<"after add index, size is "<<num_size<<" " <<ret_add_index<<std::endl;
+
+    const float* result_dist;
+    const int64_t* result_ids;
+    int64_t result_size = 0;
+
+    roaring::api::roaring64_bitmap_t* r1 = roaring::api::roaring64_bitmap_create();
+    const char *extra_info_search = nullptr;
+    TestFilter testfilter(r1);
+    std::cout<<"test knn_search: "<<std::endl;
+    int ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist,result_ids,result_size,
+                                                 100, true/*need_extra_info*/, extra_info_search, &testfilter);
+    std::string s1(extra_info_search, extra_info_search + extra_info_sz);
+    std::cout << s1 << std::endl;
+    roaring64_bitmap_add_range(r1, 0, 19800);
+
+    std::cout<<"test knn_search2: "<<std::endl;
+    ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist,result_ids,result_size,
+                                                 100, true/*need_extra_info*/, extra_info_search, &testfilter);
+    std::string s2(extra_info_search, extra_info_search + extra_info_sz);
+    std::cout << s2 << std::endl;
+    const float *distances = nullptr;
+    ret_knn_search = obvectorlib::cal_distance_by_id(index_handler, vectors+dim*(num_vectors-1), result_ids, result_size, distances);
+    for (int i = 0; i < result_size; i++) {
+        std::cout << "result: " << result_ids[i] << " " << result_dist[i] << std::endl;
+        std::cout << "calres: " << result_ids[i] << " " << distances[i] << std::endl;
+    }
+    obvectorlib::delete_index(index_handler);
+    free(test_ptr);
+    return 0;
+}
+
+int64_t hgraph_iter_filter_example()
+{
+    std::cout<<"test hgraph_iter_filter_example: "<<std::endl;
+    bool is_init = obvectorlib::is_init();
+    obvectorlib::VectorIndexPtr index_handler = NULL;
+    int dim = 1536;
+    int max_degree = 16;
+    int ef_search = 200;
+    int ef_construction = 100;
+    DefaultAllocator default_allocator;
+    const char* const METRIC_L2 = "l2";
+    const char* const METRIC_IP = "ip";
+
+    const char* const DATATYPE_FLOAT32 = "float32";
+    void * test_ptr = default_allocator.Allocate(10);
+    int ret_create_index = obvectorlib::create_index(index_handler,
+                                                     obvectorlib::HNSW_SQ_TYPE,
+                                                     DATATYPE_FLOAT32,
+                                                     METRIC_L2,
+                                                     dim,
+                                                     max_degree,
+                                                     ef_construction,
+                                                     ef_search,
+                                                     &default_allocator);
+   
+    if (ret_create_index!=0) return 333;
+    int num_vectors = 10000;
+    auto ids = new int64_t[num_vectors];
+    auto vectors = new float[dim * num_vectors];
+    std::mt19937 rng;
+    rng.seed(47);
+    std::uniform_real_distribution<> distrib_real;
+    for (int64_t i = 0; i < num_vectors; ++i) {
+        ids[i] = i;
+    }
+    for (int64_t i = 0; i < dim * num_vectors; ++i) {
+        vectors[i] = distrib_real(rng);
+    }
+
+    int inc_num = 10000;
+    auto inc = new float[dim * inc_num];
+    for (int64_t i = 0; i < dim * inc_num; ++i) {
+        inc[i] = distrib_real(rng);
+    }
+    auto ids2 = new int64_t[inc_num];
+    for (int64_t i = 0; i < inc_num; ++i) {
+        ids2[i] = i + num_vectors;
+    }
+    int ret_build_index = obvectorlib::build_index(index_handler, vectors, ids, dim, num_vectors);
+ 
+    int ret_add_index = obvectorlib::add_index(index_handler, inc, ids2, dim,inc_num);
+    
+    const float* result_dist;
+    const int64_t* result_ids;
+    int64_t result_size = 0;
+    
+    // vsag::IteratorContext *filter_ctx = nullptr;
+    void *iter_ctx = nullptr;
+
+    roaring::api::roaring64_bitmap_t* r1 = roaring::api::roaring64_bitmap_create();
+    roaring64_bitmap_add_range(r1, 0, 500);
+    TestFilter testfilter(r1);
+    const float *distances;
+    const char* extra_infos = nullptr;
+
+    int ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist,result_ids,result_size, 
+                                                 100, false, extra_infos, &testfilter, false, false, 0.97, iter_ctx, false);
+    ret_knn_search = obvectorlib::cal_distance_by_id(index_handler, vectors+dim*(num_vectors-1), result_ids, result_size, distances);
+    std::cout << "-------- result1: --------" << std::endl;
+    for (int i = 0; i < result_size; i++) {
+        std::cout << "result: " << result_ids[i] << " " << result_dist[i] << std::endl;
+        std::cout << "calres: " << result_ids[i] << " " << distances[i] << std::endl;
+    }    
+    
+
+    const float *distances2;
+    const float* result_dist2;
+    const int64_t* result_ids2;
+    int64_t result_size2 = 0;
+    std::cout << "-------- result2: --------" << std::endl;
+    ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist2,result_ids2,result_size2, 
+                                                 100, false, extra_infos, &testfilter, false, false, 0.97, iter_ctx, false);
+    ret_knn_search = obvectorlib::cal_distance_by_id(index_handler, vectors+dim*(num_vectors-1), result_ids2, result_size2, distances2);
+    for (int i = 0; i < result_size2; i++) {
+        std::cout << "result: " << result_ids2[i] << " " << result_dist2[i] << std::endl;
+        std::cout << "calres: " << result_ids2[i] << " " << distances2[i] << std::endl;
+    }
+
+    const float *distances3;
+    const float* result_dist3;
+    const int64_t* result_ids3;
+    int64_t result_size3 = 0;
+    std::cout << "-------- result3: --------" << std::endl;
+    ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 20,
+                                                 result_dist3,result_ids3,result_size3, 
+                                                 100, false, extra_infos, &testfilter, false, false, 0.97, iter_ctx, true);
+    ret_knn_search = obvectorlib::cal_distance_by_id(index_handler, vectors+dim*(num_vectors-1), result_ids3, result_size3, distances3);
+    for (int i = 0; i < result_size3; i++) {
+        std::cout << "result: " << result_ids3[i] << " " << result_dist3[i] << std::endl;
+        std::cout << "calres: " << result_ids3[i] << " " << distances3[i] << std::endl;
+    }
+    obvectorlib::delete_iter_ctx(iter_ctx);
+    obvectorlib::delete_index(index_handler);
+    free(test_ptr);
+    return 0;
+}
+
+int64_t hnsw_iter_filter_example()
+{
+    std::cout<<"test iter_filter_example: "<<std::endl;
+    bool is_init = obvectorlib::is_init();
+    obvectorlib::VectorIndexPtr index_handler = NULL;
+    int dim = 1536;
+    int max_degree = 16;
+    int ef_search = 200;
+    int ef_construction = 100;
+    DefaultAllocator default_allocator;
+    const char* const METRIC_L2 = "l2";
+    const char* const METRIC_IP = "ip";
+
+    const char* const DATATYPE_FLOAT32 = "float32";
+    void * test_ptr = default_allocator.Allocate(10);
+    int ret_create_index = obvectorlib::create_index(index_handler,
+                                                     obvectorlib::HNSW_TYPE,
+                                                     DATATYPE_FLOAT32,
+                                                     METRIC_L2,
+                                                     dim,
+                                                     max_degree,
+                                                     ef_construction,
+                                                     ef_search,
+                                                     &default_allocator);
+   
+    if (ret_create_index!=0) return 333;
+    int num_vectors = 10000;
+    auto ids = new int64_t[num_vectors];
+    auto vectors = new float[dim * num_vectors];
+    std::mt19937 rng;
+    rng.seed(47);
+    std::uniform_real_distribution<> distrib_real;
+    for (int64_t i = 0; i < num_vectors; ++i) {
+        ids[i] = i;
+    }
+    for (int64_t i = 0; i < dim * num_vectors; ++i) {
+        vectors[i] = distrib_real(rng);
+    }
+
+    int inc_num = 10000;
+    auto inc = new float[dim * inc_num];
+    for (int64_t i = 0; i < dim * inc_num; ++i) {
+        inc[i] = distrib_real(rng);
+    }
+    auto ids2 = new int64_t[inc_num];
+    for (int64_t i = 0; i < inc_num; ++i) {
+        ids2[i] = i + num_vectors;
+    }
+ 
+    int ret_add_index = obvectorlib::add_index(index_handler, inc, ids2, dim,inc_num);
+    
+    const float* result_dist;
+    const int64_t* result_ids;
+    int64_t result_size = 0;
+    
+    // vsag::IteratorContext *filter_ctx = nullptr;
+    void *iter_ctx = nullptr;
+
+    roaring::api::roaring64_bitmap_t* r1 = roaring::api::roaring64_bitmap_create();
+    roaring64_bitmap_add_range(r1, 0, 500);
+    TestFilter testfilter(r1);
+    const float *distances;
+    const char* extra_infos = nullptr;
+
+    int ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist,result_ids,result_size, 
+                                                 100, false, extra_infos, &testfilter, false, false, 0.97, iter_ctx, false);
+    ret_knn_search = obvectorlib::cal_distance_by_id(index_handler, vectors+dim*(num_vectors-1), result_ids, result_size, distances);
+    std::cout << "-------- result1: --------" << std::endl;
+    for (int i = 0; i < result_size; i++) {
+        std::cout << "result: " << result_ids[i] << " " << result_dist[i] << std::endl;
+        std::cout << "calres: " << result_ids[i] << " " << distances[i] << std::endl;
+    }    
+    
+
+    const float *distances2;
+    const float* result_dist2;
+    const int64_t* result_ids2;
+    int64_t result_size2 = 0;
+    std::cout << "-------- result2: --------" << std::endl;
+    ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 10,
+                                                 result_dist2,result_ids2,result_size2, 
+                                                 100, false, extra_infos, &testfilter, false, false, 0.97, iter_ctx, false);
+    ret_knn_search = obvectorlib::cal_distance_by_id(index_handler, vectors+dim*(num_vectors-1), result_ids2, result_size2, distances2);
+    for (int i = 0; i < result_size2; i++) {
+        std::cout << "result: " << result_ids2[i] << " " << result_dist2[i] << std::endl;
+        std::cout << "calres: " << result_ids2[i] << " " << distances2[i] << std::endl;
+    }
+
+    const float *distances3;
+    const float* result_dist3;
+    const int64_t* result_ids3;
+    int64_t result_size3 = 0;
+    std::cout << "-------- result3: --------" << std::endl;
+    ret_knn_search = obvectorlib::knn_search(index_handler, vectors+dim*(num_vectors-1), dim, 20,
+                                                 result_dist3,result_ids3,result_size3, 
+                                                 100, false, extra_infos, &testfilter, false, false, 0.97, iter_ctx, true);
+    ret_knn_search = obvectorlib::cal_distance_by_id(index_handler, vectors+dim*(num_vectors-1), result_ids3, result_size3, distances3);
+    for (int i = 0; i < result_size3; i++) {
+        std::cout << "result: " << result_ids3[i] << " " << result_dist3[i] << std::endl;
+        std::cout << "calres: " << result_ids3[i] << " " << distances3[i] << std::endl;
+    }
+    obvectorlib::delete_iter_ctx(iter_ctx);
+    obvectorlib::delete_index(index_handler);
+    free(test_ptr);
+    return 0;
+}
+
+int64_t hnswbq_example() {
+    std::cout<<"test hns_bq_example: "<<std::endl;
+    bool is_init = obvectorlib::is_init();
+    obvectorlib::VectorIndexPtr index_handler = NULL;
+    int dim = 128;
+    int max_degree = 16;
+    int ef_search = 200;
+    int ef_construction = 100;
+    DefaultAllocator default_allocator;
+    const char* const METRIC_L2 = "l2";
+
+    const char* const DATATYPE_FLOAT32 = "float32";
+    void * test_ptr = default_allocator.Allocate(10);
+    int ret_create_index = obvectorlib::create_index(index_handler,
+                                                     obvectorlib::HNSW_BQ_TYPE,
+                                                     DATATYPE_FLOAT32,
+                                                     METRIC_L2,
+                                                     dim,
+                                                     max_degree,
+                                                     ef_construction,
+                                                     ef_search,
+                                                     &default_allocator);
+   
+    if (ret_create_index!=0) return 333;
+    int num_vectors = 10000;
+    auto ids = new int64_t[num_vectors];
+    auto vectors = new float[dim * num_vectors];
+    std::mt19937 rng;
+    rng.seed(47);
+    std::uniform_real_distribution<> distrib_real;
+    for (int64_t i = 0; i < num_vectors; ++i) {
+        ids[i] = i + num_vectors*10;
+    }
+    for (int64_t i = 0; i < dim * num_vectors; ++i) {
+        vectors[i] = distrib_real(rng);
+    }
+    int ret_build_index = obvectorlib::build_index(index_handler, vectors, ids, dim, num_vectors);
+
+    int64_t num_size = 0;
+    int ret_get_element = obvectorlib::get_index_number(index_handler, num_size);
+    std::cout<<"after add index, size is "<<num_size<<" " <<ret_get_element<<std::endl;
+    
+    const float* result_dist;
+    const int64_t* result_ids;
+    int64_t result_size = 0;
+    auto query_vector = new float[dim];
+    for (int64_t i = 0; i < dim; ++i) {
+        query_vector[i] = distrib_real(rng);
+    }
+
+    roaring::api::roaring64_bitmap_t* r1 = roaring::api::roaring64_bitmap_create();
+
+    roaring::api::roaring64_bitmap_add(r1, 18);
+    roaring::api::roaring64_bitmap_add(r1, 1169);
+    roaring::api::roaring64_bitmap_add(r1, 1285);
+    std::cout << "before search" << std::endl;
+    TestFilter testfilter(r1);
+    const char *extra_info = nullptr;
+    int ret_knn_search = obvectorlib::knn_search(index_handler, query_vector, dim, 10,
+                                                 result_dist,result_ids,result_size, 
+                                                 100, false/*need_extra_info*/, extra_info, &testfilter);
+    
+    for (int i = 0; i < result_size; i++) {
+        std::cout << "result: " << result_ids[i] << " " << result_dist[i] << std::endl;
+    }
+    int inc_num = 1000;
+    auto inc = new float[dim * inc_num];
+    for (int64_t i = 0; i < dim * inc_num; ++i) {
+        inc[i] = distrib_real(rng);
+    }
+    auto ids2 = new int64_t[inc_num];
+    for (int64_t i = 0; i < inc_num; ++i) {
+        ids2[i] = i + num_vectors*100;
+    }
+    obvectorlib::delete_index(index_handler);
+    free(test_ptr);
+    return 0;
+}
+
+int
+main() {
+    hnswsq_example();
+    example();
+    //example_extra_info();
+    hnsw_iter_filter_example();
+    hgraph_iter_filter_example();
+    hnswbq_example();
+    return 0;
+}
diff --git a/ob_vsag_lib.cpp b/ob_vsag_lib.cpp
new file mode 100644
index 0000000..ceddc5d
--- /dev/null
+++ b/ob_vsag_lib.cpp
@@ -0,0 +1,985 @@
+
+#include "ob_vsag_lib.h"
+#include "ob_vsag_lib_c.h"
+#include "nlohmann/json.hpp"
+#include "roaring/roaring64.h"
+#include <vsag/vsag.h>
+#include "vsag/errors.h"
+#include "vsag/dataset.h"
+#include "vsag/bitset.h"
+#include "vsag/allocator.h"
+#include "vsag/factory.h"
+#include "vsag/constants.h"
+#include "vsag/filter.h"
+#include "vsag/iterator_context.h"
+
+#include "default_logger.h"
+#include "vsag/logger.h"
+
+#include <fstream>
+#include <chrono>
+
+namespace obvectorlib {
+
+struct SlowTaskTimer {
+    SlowTaskTimer(const std::string& name, int64_t log_threshold_ms = 0);
+    ~SlowTaskTimer();
+
+    std::string name;
+    int64_t threshold;
+    std::chrono::steady_clock::time_point start;
+};
+
+SlowTaskTimer::SlowTaskTimer(const std::string& n, int64_t log_threshold_ms)
+    : name(n), threshold(log_threshold_ms) {
+    start = std::chrono::steady_clock::now();
+}
+
+SlowTaskTimer::~SlowTaskTimer() {
+    auto finish = std::chrono::steady_clock::now();
+    std::chrono::duration<double, std::milli> duration = finish - start;
+    if (duration.count() > threshold) {
+        if (duration.count() >= 1000) {
+            vsag::logger::debug("  {0} cost {1:.3f}s", name, duration.count() / 1000);
+        } else {
+            vsag::logger::debug("  {0} cost {1:.3f}ms", name, duration.count());
+        }
+    }
+}
+
+class ObVasgFilter : public vsag::Filter
+{
+public:
+    ObVasgFilter(float valid_ratio,
+                 const std::function<bool(int64_t)>& vid_fallback_func,
+                 const std::function<bool(const char*)>& exinfo_fallback_func) 
+        : valid_ratio_(valid_ratio), vid_fallback_func_(vid_fallback_func), exinfo_fallback_func_(exinfo_fallback_func)
+    {};
+
+    ~ObVasgFilter() {}
+    
+    bool CheckValid(int64_t id) const override {
+        return !vid_fallback_func_(id);
+    }
+
+    bool CheckValid(const char* data) const override {
+        return !exinfo_fallback_func_(data);
+    }
+
+    float ValidRatio() const override {
+        return valid_ratio_;
+    }
+
+private:
+    float valid_ratio_;
+    std::function<bool(int64_t)> vid_fallback_func_{nullptr};
+    std::function<bool(const char*)> exinfo_fallback_func_{nullptr};
+};
+
+class HnswIndexHandler
+{
+public:
+  HnswIndexHandler() = delete;
+
+  HnswIndexHandler(bool is_create, bool is_build, bool use_static, const char* dtype, const char* metric, 
+                   int max_degree, int ef_construction, int ef_search, int dim, IndexType index_type,
+                   std::shared_ptr<vsag::Index> index, vsag::Allocator* allocator, uint64_t extra_info_size):
+      is_created_(is_create),
+      is_build_(is_build),
+      use_static_(use_static),
+      dtype_(dtype),
+      metric_(metric),
+      max_degree_(max_degree),
+      ef_construction_(ef_construction),
+      ef_search_(ef_search),
+      dim_(dim),
+      index_type_(index_type),
+      index_(index),
+      allocator_(allocator),
+      extra_info_size_(extra_info_size)
+  {}
+
+  ~HnswIndexHandler() {
+    index_ = nullptr;
+    vsag::logger::debug("   after deconstruction, hnsw index addr {} : use count {}", (void*)allocator_, index_.use_count());
+  }
+  void set_build(bool is_build) { is_build_ = is_build;}
+  bool is_build(bool is_build) { return is_build_;}
+  int build_index(const vsag::DatasetPtr& base);
+  int get_index_number();
+  int add_index(const vsag::DatasetPtr& incremental);
+  int cal_distance_by_id(const float* vector, const int64_t* ids, int64_t count, const float*& dist);
+  int get_extra_info_by_ids(const int64_t* ids, 
+                            int64_t count, 
+                            char *extra_infos);
+  int get_vid_bound(int64_t &min_vid, int64_t &max_vid);
+  int knn_search(const vsag::DatasetPtr& query, int64_t topk,
+                const std::string& parameters,
+                const float*& dist, const int64_t*& ids, int64_t &result_size,
+                float valid_ratio, int index_type,
+                FilterInterface *bitmap, bool reverse_filter,
+                bool need_extra_info, const char*& extra_infos);
+  int knn_search(const vsag::DatasetPtr& query, int64_t topk,
+                const std::string& parameters,
+                const float*& dist, const int64_t*& ids, int64_t &result_size,
+                float valid_ratio, int index_type,
+                FilterInterface *bitmap, bool reverse_filter,
+                bool need_extra_info, const char*& extra_infos,
+                void *&iter_ctx, bool is_last_search);
+  std::shared_ptr<vsag::Index>& get_index() {return index_;}
+  void set_index(std::shared_ptr<vsag::Index> hnsw) {index_ = hnsw;}
+  vsag::Allocator* get_allocator() {return allocator_;}
+  inline bool get_use_static() {return use_static_;}
+  inline int get_max_degree() {return max_degree_;}
+  inline int get_ef_construction() {return ef_construction_;}
+  inline int get_index_type() { return (int)index_type_; }
+  const char *get_dtype() { return dtype_; }
+  const char *get_metric() { return metric_; }
+  inline int get_ef_search() {return ef_search_;}
+  inline int get_dim() {return dim_;}
+  inline uint64_t get_extra_info_size() {return extra_info_size_;}
+  
+private:
+  bool is_created_;
+  bool is_build_;
+  bool use_static_;
+  const char* dtype_; 
+  const char* metric_;
+  int max_degree_;
+  int ef_construction_;
+  int ef_search_;
+  int dim_;
+  IndexType index_type_;
+  std::shared_ptr<vsag::Index> index_;
+  vsag::Allocator* allocator_;
+  uint64_t extra_info_size_;
+};
+
+int HnswIndexHandler::build_index(const vsag::DatasetPtr& base) 
+{
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    if (const auto num = index_->Build(base); num.has_value()) {
+        return 0;
+    } else {
+        error = num.error().type;
+    }
+    return static_cast<int>(error);
+}
+
+int HnswIndexHandler::get_index_number() 
+{
+    return index_->GetNumElements();
+}
+
+int HnswIndexHandler::add_index(const vsag::DatasetPtr& incremental) 
+{
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    if (const auto num = index_->Add(incremental); num.has_value()) {
+        vsag::logger::debug(" after add index, index count {}", get_index_number());
+        return 0;
+    } else {
+        error = num.error().type;
+    }
+    return static_cast<int>(error);
+}
+
+int HnswIndexHandler::cal_distance_by_id(const float* vector, const int64_t* ids, int64_t count, const float*& dist)
+{
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    auto result = index_->CalDistanceById(vector, ids, count);
+    if (result.has_value()) {
+        result.value()->Owner(false);
+        dist = result.value()->GetDistances();
+        return 0;
+    } else {
+        error = result.error().type;
+    }
+    return static_cast<int>(error);
+}
+
+int HnswIndexHandler::get_extra_info_by_ids(const int64_t* ids, 
+                                            int64_t count, 
+                                            char *extra_infos)
+{
+    index_->GetExtraInfoByIds(ids, count, extra_infos);
+    return 0;
+}
+
+int HnswIndexHandler::get_vid_bound(int64_t &min_vid, int64_t &max_vid)
+{
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int64_t element_cnt = index_->GetNumElements();
+    if (element_cnt == 0) {
+        return 0;
+    } else {
+        auto result = index_->GetMinAndMaxId();
+        if (result.has_value()) {
+            min_vid = result.value().first;
+            max_vid = result.value().second;
+            return 0;
+        } else {
+            error = result.error().type;
+        }
+    }
+    return static_cast<int>(error);
+}
+
+int HnswIndexHandler::knn_search(const vsag::DatasetPtr& query, int64_t topk,
+               const std::string& parameters,
+               const float*& dist, const int64_t*& ids, int64_t &result_size,
+               float valid_ratio, int index_type,
+               FilterInterface *bitmap, bool reverse_filter,
+               bool need_extra_info, const char*& extra_infos) {
+    vsag::logger::debug("  search_parameters:{}", parameters);
+    vsag::logger::debug("  topk:{}", topk);
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    auto vid_filter = [bitmap, reverse_filter](int64_t id) -> bool {
+        if (!reverse_filter) {
+            return bitmap->test(id);
+        } else {
+            return !(bitmap->test(id));
+        }
+    };
+    auto exinfo_filter = [bitmap, reverse_filter](const char* data) -> bool {
+        if (!reverse_filter) {
+            return bitmap->test(data);
+        } else {
+            return !(bitmap->test(data));
+        }
+    };
+    tl::expected<std::shared_ptr<vsag::Dataset>, vsag::Error> result;
+    auto vsag_filter = std::make_shared<ObVasgFilter>(valid_ratio, vid_filter, exinfo_filter);
+    result = index_->KnnSearch(query, topk, parameters, bitmap == nullptr ? nullptr : vsag_filter);
+    if (result.has_value()) {
+        //result的生命周期
+        result.value()->Owner(false);
+        ids = result.value()->GetIds();
+        dist = result.value()->GetDistances();
+        result_size = result.value()->GetDim();
+        if (need_extra_info) {
+            extra_infos = result.value()->GetExtraInfos();
+        }
+        // print the results
+        for (int64_t i = 0; i < result_size; ++i) {
+            vsag::logger::debug("  knn search id : {}, distance : {}",ids[i],dist[i]);
+        }
+        return 0; 
+    } else {
+        error = result.error().type;
+    }
+
+    return static_cast<int>(error);
+}
+
+int HnswIndexHandler::knn_search(const vsag::DatasetPtr& query, int64_t topk,
+               const std::string& parameters,
+               const float*& dist, const int64_t*& ids, int64_t &result_size,
+               float valid_ratio, int index_type,
+               FilterInterface *bitmap, bool reverse_filter,
+               bool need_extra_info, const char*& extra_infos,
+               void *&iter_ctx, bool is_last_search) {
+    vsag::logger::debug("  search_parameters:{}", parameters);
+    vsag::logger::debug("  topk:{}", topk);
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    auto filter = [bitmap, reverse_filter](int64_t id) -> bool {
+        if (!reverse_filter) {
+            return bitmap->test(id);
+        } else {
+            return !(bitmap->test(id));
+        }
+    };
+    auto exinfo_filter = [bitmap, reverse_filter](const char* data) -> bool {
+        if (!reverse_filter) {
+            return bitmap->test(data);
+        } else {
+            return !(bitmap->test(data));
+        }
+    };
+    tl::expected<std::shared_ptr<vsag::Dataset>, vsag::Error> result;
+    auto vsag_filter = std::make_shared<ObVasgFilter>(valid_ratio, filter, exinfo_filter);
+    vsag::IteratorContext* input_iter = static_cast<vsag::IteratorContext*>(iter_ctx);
+    result = index_->KnnSearch(query, topk, parameters, bitmap == nullptr ? nullptr : vsag_filter, input_iter, is_last_search);
+    if (result.has_value()) {
+        iter_ctx = input_iter;
+        result.value()->Owner(false);
+        ids = result.value()->GetIds();
+        dist = result.value()->GetDistances();
+        result_size = result.value()->GetDim();
+        if (need_extra_info) {
+            extra_infos = result.value()->GetExtraInfos();
+        }
+        // print the results
+        for (int64_t i = 0; i < result_size; ++i) {
+            vsag::logger::debug("  knn search id : {}, distance : {}",ids[i],dist[i]);
+        }
+        return 0; 
+    } else {
+        error = result.error().type;
+    }
+
+    return static_cast<int>(error);
+}
+
+bool is_init_ = vsag::init();
+
+void
+set_log_level(int32_t ob_level_num) {
+    std::map<int32_t, int32_t> ob2vsag_log_level = {
+        {0 /*ERROR*/, vsag::Logger::Level::kERR},
+        {1 /*WARN*/, vsag::Logger::Level::kWARN},
+        {2 /*INFO*/, vsag::Logger::Level::kINFO},
+        {3 /*EDIAG*/, vsag::Logger::Level::kERR},
+        {4 /*WDIAG*/, vsag::Logger::Level::kWARN},
+        {5 /*TRACE*/, vsag::Logger::Level::kTRACE},
+        {6 /*DEBUG*/, vsag::Logger::Level::kDEBUG},
+    };
+    vsag::Options::Instance().logger()->SetLevel(
+        static_cast<vsag::Logger::Level>(ob2vsag_log_level[ob_level_num]));
+}
+
+bool is_init() {
+    vsag::logger::debug("TRACE LOG[Init VsagLib]:");
+    if (is_init_) {
+        vsag::logger::debug("   Init VsagLib success");
+    } else {
+        vsag::logger::debug("   Init VsagLib fail");
+    }
+    return is_init_; 
+}
+
+
+void set_logger(void *logger_ptr) {
+    vsag::Options::Instance().set_logger(static_cast<vsag::Logger*>(logger_ptr));
+    vsag::Logger::Level log_level = static_cast<vsag::Logger::Level>(1);//default is debug level
+    vsag::Options::Instance().logger()->SetLevel(log_level);
+}
+
+void set_block_size_limit(uint64_t size) {
+    vsag::Options::Instance().set_block_size_limit(size);
+}
+
+bool is_supported_index(IndexType index_type) {
+    return INVALID_INDEX_TYPE < index_type && index_type < MAX_INDEX_TYPE;
+}
+
+int create_index(VectorIndexPtr& index_handler, IndexType index_type,
+                 const char* dtype,
+                 const char* metric, int dim,
+                 int max_degree, int ef_construction, int ef_search, void* allocator,
+                 int extra_info_size/* = 0*/)
+{   
+    vsag::logger::debug("TRACE LOG[create_index]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret = 0;
+    if (dtype == nullptr || metric == nullptr) {
+        vsag::logger::debug("   null pointer addr, dtype:{}, metric:{}", (void*)dtype, (void*)metric);
+        return static_cast<int>(vsag::ErrorType::UNKNOWN_ERROR);
+    }
+    SlowTaskTimer t("z");
+    vsag::Allocator* vsag_allocator = NULL;
+    bool is_support = is_supported_index(index_type);
+    vsag::logger::debug("   index type : {}, is_supported : {}", static_cast<int>(index_type), is_support);
+    if (allocator == NULL) {
+        vsag_allocator = NULL;
+        vsag::logger::debug("   allocator is null ,use default_allocator");
+    } else {
+        vsag_allocator =  static_cast<vsag::Allocator*>(allocator);
+        vsag::logger::debug("   allocator_addr:{}",allocator);
+    }
+    nlohmann::json index_parameters;
+    std::string index_type_str;
+
+    if (index_type == HNSW_TYPE) {
+        // create index
+        bool use_static = false;
+        index_type_str = "hnsw";
+        nlohmann::json hnsw_parameters{{"max_degree", max_degree},
+                                {"ef_construction", ef_construction},
+                                {"ef_search", ef_search},
+                                {"use_static", use_static}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"hnsw", hnsw_parameters}}; 
+    } else if (index_type == HNSW_SQ_TYPE) {
+        // create hnsw sq index
+        index_type_str = "hgraph";
+        nlohmann::json hnswsq_parameters{{"base_quantization_type", "sq8"},
+                                         // NOTE(liyao): max_degree compatible with behavior of HNSW, which is doubling the m value 
+                                         {"max_degree", max_degree * 2}, 
+                                         {"ef_construction", ef_construction},
+                                         {"build_thread_count", 0}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"extra_info_size", extra_info_size}, {"index_param", hnswsq_parameters}}; 
+    } else if (index_type == HGRAPH_TYPE) {
+        // create hnsw fp index
+        index_type_str = "hgraph";
+        nlohmann::json hnswsq_parameters{{"base_quantization_type", "fp32"},
+                                         // NOTE(liyao): max_degree compatible with behavior of HNSW, which is doubling the m value 
+                                         {"max_degree", max_degree * 2}, 
+                                         {"ef_construction", ef_construction},
+                                         {"build_thread_count", 0}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"extra_info_size", extra_info_size}, {"index_param", hnswsq_parameters}}; 
+    } else if (index_type == HNSW_BQ_TYPE) {
+        // create hnsw bq index
+        index_type_str = "hgraph";
+        nlohmann::json hnswsq_parameters{{"base_quantization_type", "rabitq"},
+                                         // NOTE(liyao): max_degree compatible with behavior of HNSW, which is doubling the m value 
+                                         {"max_degree", max_degree * 2}, 
+                                         {"ef_construction", ef_construction},
+                                         {"build_thread_count", 0},
+                                         {"use_reorder", true},
+                                         {"ignore_reorder", true},
+                                         {"precise_quantization_type", "fp32"},
+                                         {"precise_io_type", "block_memory_io"}}; 
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"extra_info_size", extra_info_size}, {"index_param", hnswsq_parameters}}; 
+    } else if (!is_support) {
+        error = vsag::ErrorType::UNSUPPORTED_INDEX;
+        vsag::logger::debug("   fail to create hnsw index , index type not supported:{}", static_cast<int>(index_type));
+        return static_cast<int>(error);
+    }
+
+    if (auto index = vsag::Factory::CreateIndex(index_type_str, index_parameters.dump(), vsag_allocator);
+        index.has_value()) {
+        std::shared_ptr<vsag::Index> hnsw;
+        hnsw = index.value();
+        HnswIndexHandler* hnsw_index = new HnswIndexHandler(true,
+                                                            false,
+                                                            false,
+                                                            dtype,
+                                                            metric,
+                                                            max_degree,
+                                                            ef_construction,
+                                                            ef_search,
+                                                            dim,
+                                                            index_type,
+                                                            hnsw,
+                                                            vsag_allocator,
+                                                            extra_info_size);
+        index_handler = static_cast<VectorIndexPtr>(hnsw_index);
+        vsag::logger::debug("   success to create hnsw index , index parameter:{}, allocator addr:{}",index_parameters.dump(), (void*)vsag_allocator);
+        return 0;
+    } else {
+        error = index.error().type;
+        vsag::logger::debug("   fail to create hnsw index , index parameter:{}", index_parameters.dump());
+    }
+    ret = static_cast<int>(error);
+    if (ret != 0) {
+        vsag::logger::error("   create index error happend, ret={}", static_cast<int>(error));
+    }
+    return ret;
+}
+
+int build_index(VectorIndexPtr& index_handler, float* vector_list, int64_t* ids, int dim, int size, char *extra_infos/* = nullptr*/) {
+    vsag::logger::debug("TRACE LOG[build_index]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret =  0;
+    if (index_handler == nullptr || vector_list == nullptr || ids == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}, ids:{}, ids:{}",
+                                                   (void*)index_handler, (void*)vector_list, (void*)ids);
+        return static_cast<int>(error);
+    }
+    SlowTaskTimer t("build_index");
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    auto dataset = vsag::Dataset::Make();
+    dataset->Dim(dim)
+           ->NumElements(size)
+           ->Ids(ids)
+           ->Float32Vectors(vector_list)
+           ->Owner(false);
+    if (extra_infos != nullptr) {
+        dataset->ExtraInfos(extra_infos);
+    }
+    ret = hnsw->build_index(dataset);
+    if (ret != 0) {
+        vsag::logger::error("   build index error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+
+int add_index(VectorIndexPtr& index_handler, float* vector, int64_t* ids, int dim, int size, char *extra_info/* = nullptr*/) {
+    vsag::logger::debug("TRACE LOG[add_index]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret = 0;
+    if (index_handler == nullptr || vector == nullptr || ids == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}, ids:{}, ids:{}",
+                                                   (void*)index_handler, (void*)vector, (void*)ids);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    SlowTaskTimer t("add_index");
+    // add index
+    auto incremental = vsag::Dataset::Make();
+    incremental->Dim(dim)
+        ->NumElements(size)
+        ->Ids(ids)
+        ->Float32Vectors(vector)
+        ->Owner(false);
+    if (extra_info != nullptr) {
+        incremental->ExtraInfos(extra_info);
+    }
+    ret = hnsw->add_index(incremental);
+    if (ret != 0) {
+        vsag::logger::error("   add index error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+int get_index_type(VectorIndexPtr& index_handler) {
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    return hnsw->get_index_type(); 
+}
+
+int get_index_number(VectorIndexPtr& index_handler, int64_t &size) {
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    if (index_handler == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}", (void*)index_handler);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    size = hnsw->get_index_number();
+    return 0;
+}
+
+int cal_distance_by_id(VectorIndexPtr& index_handler, 
+                        const float* vector, 
+                        const int64_t* ids, 
+                        int64_t count, 
+                        const float *&distances)
+{
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    if (index_handler == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}", (void*)index_handler);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler); 
+    int ret = hnsw->cal_distance_by_id(vector, ids, count, distances);
+    if (ret != 0) {
+        vsag::logger::error("   knn search error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+extern int get_vid_bound(VectorIndexPtr& index_handler, int64_t &min_vid, int64_t &max_vid)
+{
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    if (index_handler == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}", (void*)index_handler);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler); 
+    int ret = hnsw->get_vid_bound(min_vid, max_vid);
+    if (ret != 0) {
+        vsag::logger::error("   get vid bound error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+int knn_search(VectorIndexPtr& index_handler, float* query_vector,int dim, int64_t topk,
+               const float*& dist, const int64_t*& ids, int64_t &result_size, int ef_search,
+               bool need_extra_info, const char*& extra_infos,
+               void* invalid, bool reverse_filter, bool use_extra_info_filter, float valid_ratio) {
+    vsag::logger::debug("TRACE LOG[knn_search]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret = 0;
+    if (index_handler == nullptr || query_vector == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}, query_vector:{}",
+                                                   (void*)index_handler, (void*)query_vector);
+        return static_cast<int>(error);
+    }
+    SlowTaskTimer t("knn_search");
+    FilterInterface *bitmap = static_cast<FilterInterface*>(invalid);
+    bool owner_set = false;
+    nlohmann::json search_parameters;
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    const IndexType index_type =static_cast<IndexType>(hnsw->get_index_type());
+    if (HNSW_SQ_TYPE == index_type || HNSW_BQ_TYPE == index_type || HGRAPH_TYPE == index_type) {
+        search_parameters = {{"hgraph", {{"ef_search", ef_search}, {"use_extra_info_filter", use_extra_info_filter}}},};
+        owner_set = true;
+    } else {
+        search_parameters = {{"hnsw", {{"ef_search", ef_search}, {"skip_ratio", 0.7f}}},};
+    }
+    auto query = vsag::Dataset::Make();
+    query->NumElements(1)->Dim(dim)->Float32Vectors(query_vector)->Owner(false);
+    ret = hnsw->knn_search(
+        query, topk, search_parameters.dump(), dist, ids, result_size, valid_ratio, index_type,
+        bitmap, reverse_filter,
+        need_extra_info, extra_infos);
+    if (ret != 0) {
+        vsag::logger::error("   knn search error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+int knn_search(VectorIndexPtr& index_handler, float* query_vector,int dim, int64_t topk,
+               const float*& dist, const int64_t*& ids, int64_t &result_size, int ef_search,
+               bool need_extra_info, const char*& extra_infos,
+               void* invalid, bool reverse_filter, bool use_extra_info_filter, float valid_ratio, 
+               void *&iter_ctx, bool is_last_search) {
+    vsag::logger::debug("TRACE LOG[knn_search]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret = 0;
+    if (index_handler == nullptr || query_vector == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}, query_vector:{}",
+                                                   (void*)index_handler, (void*)query_vector);
+        return static_cast<int>(error);
+    }
+    SlowTaskTimer t("knn_search");
+    FilterInterface *bitmap = static_cast<FilterInterface*>(invalid);
+    bool owner_set = false;
+    nlohmann::json search_parameters;
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    const IndexType index_type =static_cast<IndexType>(hnsw->get_index_type());
+    if (HNSW_SQ_TYPE == index_type || HNSW_BQ_TYPE == index_type || HGRAPH_TYPE == index_type) {
+        search_parameters = {{"hgraph", {{"ef_search", ef_search}, {"use_extra_info_filter", use_extra_info_filter}}},};
+        owner_set = true;
+    } else {
+        search_parameters = {{"hnsw", {{"ef_search", ef_search}, {"skip_ratio", 0.7f}}},};
+    }
+    auto query = vsag::Dataset::Make();
+    query->NumElements(1)->Dim(dim)->Float32Vectors(query_vector)->Owner(false);
+    ret = hnsw->knn_search(
+        query, topk, search_parameters.dump(), dist, ids, result_size, valid_ratio, index_type,
+        bitmap, reverse_filter,
+        need_extra_info, extra_infos, 
+        iter_ctx, is_last_search);
+    if (ret != 0) {
+        vsag::logger::error("   knn search error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+int serialize(VectorIndexPtr& index_handler, const std::string dir) {
+    vsag::logger::debug("TRACE LOG[serialize]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret =  0;
+    if (index_handler == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}", (void*)index_handler);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    if (auto bs = hnsw->get_index()->Serialize(); bs.has_value()) {
+        hnsw = nullptr;
+        auto keys = bs->GetKeys();
+        for (auto key : keys) {
+            vsag::Binary b = bs->Get(key);
+            std::ofstream file(dir + "hnsw.index." + key, std::ios::binary);
+            file.write((const char*)b.data.get(), b.size);
+            file.close();
+        }
+        std::ofstream metafile(dir + "hnsw.index._meta", std::ios::out);
+        for (auto key : keys) {
+            metafile << key << std::endl;
+        }
+        metafile.close();
+        return 0;
+    } else {
+        error = bs.error().type;
+    }
+    ret = static_cast<int>(error);
+    if (ret != 0) {
+        vsag::logger::error("   serialize error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+int fserialize(VectorIndexPtr& index_handler, std::ostream& out_stream) {
+    vsag::logger::debug("TRACE LOG[fserialize]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret = 0;
+    if (index_handler == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}", (void*)index_handler);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    if (auto bs = hnsw->get_index()->Serialize(out_stream); bs.has_value()) {
+        return 0;
+    } else {
+        error = bs.error().type;
+    }
+    ret = static_cast<int>(error);
+    if (ret != 0) {
+        vsag::logger::error("   fserialize error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+int fdeserialize(VectorIndexPtr& index_handler, std::istream& in_stream) {
+    vsag::logger::debug("TRACE LOG[fdeserialize]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret = 0;
+    if (index_handler == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}", (void*)index_handler);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    std::shared_ptr<vsag::Index> hnsw_index;
+    bool use_static = hnsw->get_use_static();
+    const char *metric = hnsw->get_metric();
+    const char *dtype = hnsw->get_dtype();
+    int max_degree = hnsw->get_max_degree();
+    int ef_construction = hnsw->get_ef_construction();
+    int ef_search = hnsw->get_ef_search();
+    int dim = hnsw->get_dim();
+    int index_type = hnsw->get_index_type();
+    uint64_t extra_info_size = hnsw->get_extra_info_size();
+    const char *base_quantization_type = (index_type == HNSW_SQ_TYPE) ? "sq8" : ((index_type == HNSW_BQ_TYPE) ? "rabitq" : "fp32");
+    nlohmann::json index_parameters;
+    if (HNSW_TYPE == index_type) {
+        nlohmann::json hnsw_parameters{{"max_degree", max_degree},
+                                    {"ef_construction", ef_construction},
+                                    {"ef_search", ef_search},
+                                    {"use_static", use_static}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"hnsw", hnsw_parameters}};
+    } else if (HNSW_SQ_TYPE == index_type) {
+        nlohmann::json hnswsq_parameters{{"base_quantization_type", base_quantization_type},
+                                        {"max_degree", max_degree},
+                                        {"ef_construction", ef_construction},
+                                        {"build_thread_count", 0}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"extra_info_size", extra_info_size}, {"index_param", hnswsq_parameters}};
+    } else if (HNSW_BQ_TYPE == index_type) {
+        nlohmann::json hnswbq_parameters{{"base_quantization_type", "rabitq"}, 
+                                            {"max_degree", max_degree}, 
+                                            {"ef_construction", ef_construction},
+                                            {"build_thread_count", 0},
+                                            {"use_reorder", true},
+                                            {"ignore_reorder", true},
+                                            {"precise_quantization_type", "fp32"},
+                                            {"precise_io_type", "block_memory_io"}};  
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"extra_info_size", extra_info_size}, {"index_param", hnswbq_parameters}};
+    } else if (HGRAPH_TYPE == index_type) {
+        nlohmann::json hnswsq_parameters{{"base_quantization_type", base_quantization_type},
+                                        {"max_degree", max_degree},
+                                        {"ef_construction", ef_construction},
+                                        {"build_thread_count", 0}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"extra_info_size", extra_info_size}, {"index_param", hnswsq_parameters}};       
+    }
+
+    vsag::logger::debug("   Deserilize hnsw index , index parameter:{}, allocator addr:{}",index_parameters.dump(),(void*)hnsw->get_allocator());
+    if (index_type == HNSW_TYPE) {
+        if (auto index = vsag::Factory::CreateIndex("hnsw", index_parameters.dump(), hnsw->get_allocator());
+            index.has_value()) {
+            hnsw_index = index.value();
+        } else {
+            error = index.error().type;
+            return static_cast<int>(error);
+        }
+    } else {
+        if (auto index = vsag::Factory::CreateIndex("hgraph", index_parameters.dump(), hnsw->get_allocator());
+            index.has_value()) {
+            hnsw_index = index.value();
+        } else {
+            error = index.error().type;
+            return static_cast<int>(error);
+        }        
+    }
+    if (ret != 0) {
+
+    } else if (auto bs = hnsw_index->Deserialize(in_stream); bs.has_value()) {
+        hnsw->set_index(hnsw_index);
+        return 0;
+    } else {
+        error = bs.error().type;
+        ret = static_cast<int>(error);
+    }
+    if (ret != 0) {
+        vsag::logger::error("   fdeserialize error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+int deserialize_bin(VectorIndexPtr& index_handler,const std::string dir) {
+    vsag::logger::debug("TRACE LOG[deserialize]:");
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    int ret = 0;
+    if (index_handler == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler={}", (void*)index_handler);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler);
+    std::ifstream metafile(dir + "hnsw.index._meta", std::ios::in);
+    std::vector<std::string> keys;
+    std::string line;
+    while (std::getline(metafile, line)) {
+        keys.push_back(line);
+    }
+    metafile.close();
+
+    vsag::BinarySet bs;
+    for (auto key : keys) {
+        std::ifstream file(dir + "hnsw.index." + key, std::ios::in);
+        file.seekg(0, std::ios::end);
+        vsag::Binary b;
+        b.size = file.tellg();
+        b.data.reset(new int8_t[b.size]);
+        file.seekg(0, std::ios::beg);
+        file.read((char*)b.data.get(), b.size);
+        bs.Set(key, b);
+    }
+    bool use_static = hnsw->get_use_static();
+    const char *metric = hnsw->get_metric();
+    const char *dtype = hnsw->get_dtype();
+    int max_degree = hnsw->get_max_degree();
+    int ef_construction = hnsw->get_ef_construction();
+    int ef_search = hnsw->get_ef_search();
+    int dim = hnsw->get_dim();
+    int index_type = hnsw->get_index_type();
+    uint64_t extra_info_size = hnsw->get_extra_info_size();
+    const char *base_quantization_type = (index_type == HNSW_SQ_TYPE) ? "sq8" : ((index_type == HNSW_BQ_TYPE) ? "rabitq" : "fp32");
+    nlohmann::json index_parameters;
+    if (index_type == HNSW_TYPE) {
+        nlohmann::json hnsw_parameters{{"max_degree", max_degree},
+                                    {"ef_construction", ef_construction},
+                                    {"ef_search", ef_search},
+                                    {"use_static", use_static}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"hnsw", hnsw_parameters}};
+     } else if (index_type == HNSW_BQ_TYPE) {
+        nlohmann::json hnswbq_parameters{{"base_quantization_type", base_quantization_type}, 
+                                            {"max_degree", max_degree}, 
+                                            {"ef_construction", ef_construction},
+                                            {"build_thread_count", 0},
+                                            {"extra_info_size", extra_info_size},
+                                            {"use_reorder", true},
+                                            {"ignore_reorder", true},
+                                            {"precise_quantization_type", "fp32"},
+                                            {"precise_io_type", "block_memory_io"}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"index_param", hnswbq_parameters}};
+    } else {
+        nlohmann::json hnswsq_parameters{{"base_quantization_type", base_quantization_type},
+                                            {"max_degree", max_degree}, 
+                                            {"ef_construction", ef_construction},
+                                            {"build_thread_count", 0},
+                                            {"extra_info_size", extra_info_size}};
+        index_parameters = {{"dtype", dtype}, {"metric_type", metric}, {"dim", dim}, {"index_param", hnswsq_parameters}};
+    }
+   
+    vsag::logger::debug("   Deserilize hnsw index , index parameter:{}, allocator addr:{}",index_parameters.dump(),(void*)hnsw->get_allocator());
+    std::shared_ptr<vsag::Index> hnsw_index;
+    if (index_type == HNSW_TYPE) {
+        if (auto index = vsag::Factory::CreateIndex("hnsw", index_parameters.dump(), hnsw->get_allocator());
+            index.has_value()) {
+            hnsw_index = index.value();
+        } else {
+            error = index.error().type;
+            return static_cast<int>(error);
+        }
+    } else {
+        if (auto index = vsag::Factory::CreateIndex("hgraph", index_parameters.dump(), hnsw->get_allocator());
+            index.has_value()) {
+            hnsw_index = index.value();
+        } else {
+            error = index.error().type;
+            return static_cast<int>(error);
+        }        
+    }
+    hnsw_index->Deserialize(bs);
+    hnsw->set_index(hnsw_index);
+    return 0;
+}
+
+int delete_index(VectorIndexPtr& index_handler) {
+    vsag::logger::debug("TRACE LOG[delete_index]");
+    vsag::logger::debug("   delete index handler addr {} : hnsw index use count {}",(void*)static_cast<HnswIndexHandler*>(index_handler)->get_index().get(),static_cast<HnswIndexHandler*>(index_handler)->get_index().use_count());
+    if (index_handler != NULL) {
+        delete static_cast<HnswIndexHandler*>(index_handler);
+        index_handler = NULL;
+    }
+    return 0;
+}
+
+void delete_iter_ctx(void *iter_ctx) {
+    vsag::logger::debug("TRACE LOG[delete_iter_ctx]");
+    if (iter_ctx != NULL) {
+        delete static_cast<vsag::IteratorContext*>(iter_ctx);
+        iter_ctx = NULL;
+    }
+}
+
+int get_extra_info_by_ids(VectorIndexPtr& index_handler, 
+                          const int64_t* ids, 
+                          int64_t count, 
+                          char *extra_infos) {
+    vsag::ErrorType error = vsag::ErrorType::UNKNOWN_ERROR;
+    if (index_handler == nullptr) {
+        vsag::logger::debug("   null pointer addr, index_handler:{}", (void*)index_handler);
+        return static_cast<int>(error);
+    }
+    HnswIndexHandler* hnsw = static_cast<HnswIndexHandler*>(index_handler); 
+    int ret = hnsw->get_extra_info_by_ids(ids, count, extra_infos);
+    if (ret != 0) {
+        vsag::logger::error("   knn search error happend, ret={}", ret);
+    }
+    return ret;
+}
+
+int64_t example() {
+    return 0;
+}
+
+extern bool is_init_c() {
+    return is_init();
+}
+
+extern void set_logger_c(void *logger_ptr) {
+    set_logger(logger_ptr);
+}
+
+extern void set_block_size_limit_c(uint64_t size) {
+    set_block_size_limit(size);
+}
+
+extern bool is_supported_index_c(IndexType index_type) {
+    return is_supported_index(index_type);
+}
+
+extern int create_index_c(VectorIndexPtr& index_handler, IndexType index_type,
+                 const char* dtype,
+                 const char* metric, int dim,
+                 int max_degree, int ef_construction, int ef_search, void* allocator)
+{   
+    return create_index(index_handler, index_type, dtype, metric, dim, max_degree, ef_construction, ef_search, allocator);
+}
+
+extern int build_index_c(VectorIndexPtr& index_handler,float* vector_list, int64_t* ids, int dim, int size) {
+
+    return build_index(index_handler, vector_list, ids, dim, size);
+}
+
+
+extern int add_index_c(VectorIndexPtr& index_handler,float* vector, int64_t* ids, int dim, int size) {
+    return  add_index(index_handler, vector, ids, dim, size);
+}
+
+extern int get_index_number_c(VectorIndexPtr& index_handler, int64_t &size) {
+    return get_index_number(index_handler, size);
+}
+
+extern int get_index_type_c(VectorIndexPtr& index_handler) {
+    return get_index_type(index_handler);
+}
+
+extern int knn_search_c(VectorIndexPtr& index_handler,float* query_vector,int dim, int64_t topk,
+               const float*& dist, const int64_t*& ids, int64_t &result_size, int ef_search, 
+               bool need_extra_info, const char*& extra_infos,
+               void* invalid, bool reverse_filter, bool use_extra_info_filter) {
+    return knn_search(index_handler, query_vector, dim, topk, dist, ids, result_size,
+                      ef_search, need_extra_info, extra_infos, invalid, reverse_filter, use_extra_info_filter);
+}
+
+extern int serialize_c(VectorIndexPtr& index_handler, const std::string dir) {
+    return serialize(index_handler, dir);
+}
+
+extern int fserialize_c(VectorIndexPtr& index_handler, std::ostream& out_stream) {
+    return fserialize(index_handler, out_stream);
+}
+
+extern int delete_index_c(VectorIndexPtr& index_handler) {
+    return delete_index(index_handler);
+}
+extern int fdeserialize_c(VectorIndexPtr& index_handler, std::istream& in_stream) {
+    return fdeserialize(index_handler, in_stream);
+}
+
+extern int deserialize_bin_c(VectorIndexPtr& index_handler,const std::string dir) {
+    return deserialize_bin(index_handler, dir);
+}
+
+} //namespace obvectorlib
diff --git a/ob_vsag_lib.h b/ob_vsag_lib.h
new file mode 100644
index 0000000..dbc6291
--- /dev/null
+++ b/ob_vsag_lib.h
@@ -0,0 +1,91 @@
+#ifndef OB_VSAG_LIB_H
+#define OB_VSAG_LIB_H
+#include <stdint.h>
+#include <iostream>
+#include <map>
+namespace obvectorlib {
+
+
+int64_t example();
+typedef void* VectorIndexPtr;
+extern bool is_init_;
+enum IndexType {
+  INVALID_INDEX_TYPE = -1,
+  HNSW_TYPE = 0,
+  HNSW_SQ_TYPE = 1,
+  // Keep it the same as ObVectorIndexAlgorithmType
+  // IVF_FLAT_TYPE,
+  // IVF_SQ8_TYPE,
+  // IVF_PQ_TYPE,
+  HNSW_BQ_TYPE = 5,
+  HGRAPH_TYPE = 6,
+  MAX_INDEX_TYPE
+};
+
+class FilterInterface {
+public:
+  virtual bool test(int64_t id) = 0;
+  virtual bool test(const char* data) = 0;
+};
+/**
+ *   * Get the version based on git revision
+ *     * 
+ *       * @return the version text
+ *         */
+extern std::string
+version();
+
+/**
+ *   * Init the vsag library
+ *     * 
+ *       * @return true always
+ *         */
+extern bool is_init();
+
+/*
+ * *trace = 0
+ * *debug = 1
+ * *info = 2
+ * *warn = 3
+ * *err = 4
+ * *critical = 5
+ * *off = 6
+ * */
+extern void set_log_level(int32_t ob_level_num);
+extern void set_logger(void *logger_ptr);
+extern void set_block_size_limit(uint64_t size);
+extern bool is_supported_index(IndexType index_type);
+extern int create_index(VectorIndexPtr& index_handler, IndexType index_type,
+                        const char* dtype,
+                        const char* metric,int dim,
+                        int max_degree, int ef_construction, int ef_search, void* allocator = NULL,
+                        int extra_info_size = 0);
+extern int build_index(VectorIndexPtr& index_handler, float* vector_list, int64_t* ids, int dim, int size, char *extra_infos = nullptr);
+extern int add_index(VectorIndexPtr& index_handler, float* vector, int64_t* ids, int dim, int size, char *extra_info = nullptr);
+extern int get_index_number(VectorIndexPtr& index_handler, int64_t &size);
+extern int get_index_type(VectorIndexPtr& index_handler);
+extern int cal_distance_by_id(VectorIndexPtr& index_handler, const float* vector, const int64_t* ids, int64_t count, const float *&distances);
+extern int get_vid_bound(VectorIndexPtr& index_handler, int64_t &min_vid, int64_t &max_vid);
+extern int knn_search(VectorIndexPtr& index_handler,float* query_vector, int dim, int64_t topk,
+                      const float*& dist, const int64_t*& ids, int64_t &result_size, int ef_search,
+                      bool need_extra_info, const char*& extra_infos,
+                      void* invalid, bool reverse_filter, bool use_extra_info_filter,
+                      float valid_ratio, void *&iter_ctx, bool is_last_search = false);
+extern int knn_search(VectorIndexPtr& index_handler,float* query_vector, int dim, int64_t topk,
+                      const float*& dist, const int64_t*& ids, int64_t &result_size, int ef_search,
+                      bool need_extra_info, const char*& extra_infos,
+                      void* invalid = NULL, bool reverse_filter = false,
+                      bool use_extra_info_filter = false, float valid_ratio = 1);
+extern int serialize(VectorIndexPtr& index_handler, const std::string dir);
+extern int deserialize_bin(VectorIndexPtr& index_handler, const std::string dir);
+extern int fserialize(VectorIndexPtr& index_handler, std::ostream& out_stream);
+extern int fdeserialize(VectorIndexPtr& index_handler, std::istream& in_stream);
+extern int delete_index(VectorIndexPtr& index_handler);
+extern void delete_iter_ctx(void *iter_ctx);
+extern int get_extra_info_by_ids(VectorIndexPtr& index_handler, 
+                                const int64_t* ids, 
+                                int64_t count, 
+                                char *extra_infos);
+} // namesapce obvectorlib
+#endif // OB_VSAG_LIB_H
+
diff --git a/ob_vsag_lib_c.h b/ob_vsag_lib_c.h
new file mode 100644
index 0000000..cd6260c
--- /dev/null
+++ b/ob_vsag_lib_c.h
@@ -0,0 +1,90 @@
+#ifndef OB_VSAG_LIB_C_H
+#define OB_VSAG_LIB_C_H
+#include "ob_vsag_lib.h"
+#include <dlfcn.h>
+// Define a macro to load function symbols
+#define LOAD_FUNCTION(handle, typeName, funcName)                             \
+    do {                                                            \
+        dlerror();  /* Clear existing errors */                     \
+        funcName = (typeName)dlsym((handle), (#funcName));          \
+        const char* dlsym_error = dlerror();                        \
+        if (dlsym_error) {                                          \
+            fprintf(stderr, "Cannot load symbol '" #funcName "': %s\n", dlsym_error); \
+            dlclose(handle);                                        \
+            return EXIT_FAILURE;                                    \
+        }                                                           \
+    } while (0)
+
+
+
+namespace obvectorlib {
+#ifdef __cplusplus
+extern "C" {
+#endif
+typedef bool (*is_init_ptr)();
+extern bool is_init_c();
+
+typedef void (*set_log_level_ptr)(int64_t level_num);
+extern void set_log_level_c(int64_t level_num);
+
+typedef void (*set_logger_ptr)(void *logger_ptr);
+extern void set_logger_c(void *logger_ptr);
+
+typedef void (*set_block_size_limit_ptr)(uint64_t size);
+extern void set_block_size_limit_c(uint64_t size);
+
+typedef bool (*is_supported_index_ptr)(IndexType index_type);
+extern bool is_supported_index_c(IndexType index_type);
+
+typedef int (*create_index_ptr)(VectorIndexPtr& index_handler, IndexType index_type,
+                        const char* dtype,
+                        const char* metric,int dim,
+                        int max_degree, int ef_construction, int ef_search, void* allocator);
+extern int create_index_c(VectorIndexPtr& index_handler, IndexType index_type,
+                        const char* dtype,
+                        const char* metric,int dim,
+                        int max_degree, int ef_construction, int ef_search, void* allocator = NULL);
+
+typedef int (*build_index_ptr)(VectorIndexPtr& index_handler, float* vector_list, int64_t* ids, int dim, int size);              
+extern int build_index_c(VectorIndexPtr& index_handler, float* vector_list, int64_t* ids, int dim, int size);
+
+typedef int (*add_index_ptr)(VectorIndexPtr& index_handler, float* vector, int64_t* ids, int dim, int size);
+extern int add_index_c(VectorIndexPtr& index_handler, float* vector, int64_t* ids, int dim, int size);
+
+typedef int (*get_index_number_ptr)(VectorIndexPtr& index_handler, int64_t &size);
+extern int get_index_number_c(VectorIndexPtr& index_handler, int64_t &size);
+
+typedef int (*get_index_type_ptr)(VectorIndexPtr& index_handler);
+extern int get_index_type_c(VectorIndexPtr& index_handler);
+
+typedef int (*knn_search_ptr)(VectorIndexPtr& index_handler,float* query_vector, int dim, int64_t topk,
+                      const float*& dist, const int64_t*& ids, int64_t &result_size, int ef_search,
+                       void* invalid, bool reverse_filter);
+extern int knn_search_c(VectorIndexPtr& index_handler,float* query_vector, int dim, int64_t topk,
+                      const float*& dist, const int64_t*& ids, int64_t &result_size, int ef_search,
+                      void* invalid = NULL, bool reverse_filter = false);
+
+typedef int (*serialize_ptr)(VectorIndexPtr& index_handler, const std::string dir);          
+extern int serialize_c(VectorIndexPtr& index_handler, const std::string dir);
+
+typedef int (*deserialize_bin_ptr)(VectorIndexPtr& index_handler, const std::string dir);
+extern int deserialize_bin_c(VectorIndexPtr& index_handler, const std::string dir);
+ 
+typedef int (*delete_index_ptr)(VectorIndexPtr& index_handler);
+extern int delete_index_c(VectorIndexPtr& index_handler);
+
+typedef int (*fserialize_ptr)(VectorIndexPtr& index_handler, std::ostream& out_stream);
+extern int fserialize_c(VectorIndexPtr& index_handler, std::ostream& out_stream);
+
+typedef int (*fdeserialize_ptr)(VectorIndexPtr& index_handler, std::istream& in_stream);
+extern int fdeserialize_c(VectorIndexPtr& index_handler, std::istream& in_stream);
+
+
+
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+} // namesapce obvectorlib
+
+#endif // OB_VSAG_LIB_H
