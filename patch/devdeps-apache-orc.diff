diff --git a/c++/build-support/README.md b/c++/build-support/README.md
index 0ffad788..80966104 100644
--- a/c++/build-support/README.md
+++ b/c++/build-support/README.md
@@ -11,7 +11,7 @@ To use `run_clang_format.py` you could act like below:
 ```shell
 mkdir build
 cd build
-cmake .. -DBUILD_JAVA=OFF -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang -DCMAKE_EXPORT_COMPILE_COMMANDS=1
+cmake .. -DBUILD_JAVA=OFF -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DORC_ENABLE_CLANG_TOOLS=1
 make check-format # Do checks only
 make format # This would apply suggested changes, take care!
 ```
@@ -23,7 +23,7 @@ To use `run_clang_tidy.py` you could act like below:
 ```shell
 mkdir build
 cd build
-cmake .. -DBUILD_JAVA=OFF -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang -DCMAKE_EXPORT_COMPILE_COMMANDS=1
+cmake .. -DBUILD_JAVA=OFF -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DORC_ENABLE_CLANG_TOOLS=1
 make -j`nproc` # Important
 make check-clang-tidy # Do checks only
 make fix-clang-tidy # This would apply suggested changes, take care!
diff --git a/c++/include/orc/Reader.hh b/c++/include/orc/Reader.hh
index b015b649..bfef74be 100644
--- a/c++/include/orc/Reader.hh
+++ b/c++/include/orc/Reader.hh
@@ -392,6 +392,19 @@ namespace orc {
 
   class RowReader;
 
+  /**
+   * Cached reader context for shared row reader.
+   */
+  struct CachedReaderContext {
+    // current stripe information which can be shared by multiple row readers
+    std::unique_ptr<StripeInformation> currentStripeInfo;
+
+    // cached row indexes, the value type is `std::unordered_map<uint64_t, proto::RowIndex>`.
+    // it will point to row reader's row indexes after the row reader is created, we can set it to
+    // nullptr to disable the sharing.
+    void* rowIndexes = nullptr;
+  };
+
   /**
    * The interface for reading ORC file meta-data and constructing RowReaders.
    * This is an an abstract class that will be subclassed as necessary.
@@ -498,9 +511,15 @@ namespace orc {
     /**
      * Get the statistics about a stripe.
      * @param stripeIndex the index of the stripe (0 to N-1) to get statistics about
-     * @return the statistics about that stripe
+     * @param includeRowIndex whether the row index of the stripe is included
+     * @param selectedColumns whether the columns are selected,
+     *        nullptr means all columns are selected
+     * @return the statistics about that stripe and row group index statistics
      */
-    virtual std::unique_ptr<StripeStatistics> getStripeStatistics(uint64_t stripeIndex) const = 0;
+    virtual std::unique_ptr<StripeStatistics> getStripeStatistics(
+        uint64_t stripeIndex,
+        bool includeRowIndex = true,
+        const bool* selectedColumns = nullptr) const = 0;
 
     /**
      * Get the length of the data stripes in the file.
@@ -664,6 +683,33 @@ namespace orc {
      * @param boundary the boundary value to release cache entries
      */
     virtual void releaseBuffer(uint64_t boundary) = 0;
+
+    /**
+     * Set the cached reader context. Note that this method must be called before createRowReader.
+     * @param context the cached reader context
+     */
+    virtual void setCachedReaderContext(CachedReaderContext* context) = 0;
+  };
+
+  /**
+   * A struct to hold the arguments for the nextWithSkip reader.
+   */
+  struct ProjectArgument {
+    ProjectArgument() : numValues(0), numRead(0), skip(nullptr), next(nullptr), size(0) {}
+    ProjectArgument(size_t numValues, size_t numRead, const uint16_t* skip, const uint16_t* next,
+                    size_t size)
+        : numValues(numValues), numRead(numRead), skip(skip), next(next), size(size) {}
+
+    // Number of values after projection.
+    size_t numValues;
+    // Number of rows to read which contains both next rows and skip rows.
+    size_t numRead;
+    // Skip count array, iterate over this array to skip the rows.
+    const uint16_t* skip;
+    // Next count array, iterate over this array to get the next rows.
+    const uint16_t* next;
+    // Size of the skip and next array.
+    size_t size;
   };
 
   /**
@@ -705,6 +751,16 @@ namespace orc {
      */
     virtual bool next(ColumnVectorBatch& data) = 0;
 
+    /**
+     * Read the next row batch from the current position, the method considers the project argument
+     * to project the rows.
+     * @param data the row batch to read into.
+     * @param arg the project arguments for the next method.
+     * @return true if a non-zero number of rows were read or false if the
+     *   end of the file was reached.
+     */
+    virtual bool next(ColumnVectorBatch& data, const ProjectArgument& arg) = 0;
+
     /**
      * Get the row number of the first row in the previously read batch.
      * @return the row number of the previous batch.
diff --git a/c++/src/ColumnReader.cc b/c++/src/ColumnReader.cc
index af434c37..e7fe674f 100644
--- a/c++/src/ColumnReader.cc
+++ b/c++/src/ColumnReader.cc
@@ -111,6 +111,42 @@ namespace orc {
     rowBatch.hasNulls = false;
   }
 
+  void ColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                  uint64_t numValues,
+                                  std::vector<uint16_t>& skip,
+                                  const std::vector<uint16_t>& next,
+                                  char* notNull) {
+    if (numValues > rowBatch.capacity) {
+      rowBatch.resize(numValues);
+    }
+    rowBatch.numElements = numValues;
+    ByteRleDecoder* decoder = notNullDecoder.get();
+    uint64_t offset = 0;
+    rowBatch.hasNulls = false;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (decoder) {
+        if (skip[i] > 0) {
+          skip[i] = ColumnReader::skip(static_cast<uint64_t>(skip[i]));
+        }
+        const uint16_t nextNumValues = next[i];
+        char* notNullArray = rowBatch.notNull.data() + offset;
+        char* parentNotNull = notNull ? notNull + offset : nullptr;
+        decoder->next(notNullArray, nextNumValues, parentNotNull);
+        // check to see if there are nulls in this batch
+        for (uint64_t j = 0; !rowBatch.hasNulls && j < nextNumValues; j++) {
+          if (!notNullArray[j]) {
+            rowBatch.hasNulls = true;
+          }
+        }
+      } else if (notNull) {
+        // If we don't have a notNull stream, copy the incomingMask
+        rowBatch.hasNulls = true;
+        memcpy(rowBatch.notNull.data() + offset, notNull + offset, next[i]);
+      }
+      offset += next[i];
+    }
+  }
+
   void ColumnReader::seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) {
     if (notNullDecoder.get()) {
       notNullDecoder->seek(positions.at(columnId));
@@ -148,6 +184,12 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
   };
 
@@ -185,6 +227,27 @@ namespace orc {
     expandBytesToIntegers(ptr, numValues);
   }
 
+  template <typename BatchType>
+  void BooleanColumnReader<BatchType>::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                                    uint64_t numValues,
+                                                    std::vector<uint16_t>& skip,
+                                                    const std::vector<uint16_t>& next,
+                                                    char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    uint64_t offset = 0;
+    auto* ptr = dynamic_cast<BatchType&>(rowBatch).data.data();
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        rle_->skip(static_cast<uint64_t>(skip[i]));
+      }
+      const uint16_t nextNumValues = next[i];
+      rle_->next(reinterpret_cast<char*>(ptr) + offset, nextNumValues,
+        rowBatch.hasNulls ? rowBatch.notNull.data() + offset : nullptr);
+      offset += nextNumValues;
+    }
+    expandBytesToIntegers(ptr, numValues);
+  }
+
   template <typename BatchType>
   void BooleanColumnReader<BatchType>::seekToRowGroup(
       std::unordered_map<uint64_t, PositionProvider>& positions) {
@@ -223,6 +286,25 @@ namespace orc {
       expandBytesToIntegers(ptr, numValues);
     }
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      uint64_t offset = 0;
+      auto* ptr = dynamic_cast<BatchType&>(rowBatch).data.data();
+      for (uint64_t i = 0; i < next.size(); i++) {
+        if (skip[i] > 0) {
+          rle_->skip(static_cast<uint64_t>(skip[i]));
+        }
+        rle_->next(reinterpret_cast<char*>(ptr) + offset, next[i],
+        rowBatch.hasNulls ? rowBatch.notNull.data() + offset : nullptr);
+        offset += next[i];
+      }
+      expandBytesToIntegers(ptr, numValues);
+    }
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override {
       ColumnReader::seekToRowGroup(positions);
       rle_->seek(positions.at(columnId));
@@ -259,6 +341,23 @@ namespace orc {
                 rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr);
     }
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      uint64_t offset = 0;
+      for (uint64_t i = 0; i < next.size(); i++) {
+        if (skip[i] > 0) {
+          rle->skip(static_cast<uint64_t>(skip[i]));
+        }
+        rle->next(dynamic_cast<BatchType&>(rowBatch).data.data() + offset, next[i],
+        rowBatch.hasNulls ? rowBatch.notNull.data() + offset : nullptr);
+        offset += next[i];
+      }
+    }
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override {
       ColumnReader::seekToRowGroup(positions);
       rle->seek(positions.at(columnId));
@@ -282,7 +381,17 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
+
+   private:
+    void adjustTimestamp(int64_t* secsBuffer, int64_t* nanoBuffer, uint64_t numValues,
+                         char* notNull);
   };
 
   TimestampColumnReader::TimestampColumnReader(const Type& type, StripeStreams& stripe,
@@ -321,7 +430,36 @@ namespace orc {
     secondsRle_->next(secsBuffer, numValues, notNull);
     int64_t* nanoBuffer = timestampBatch.nanoseconds.data();
     nanoRle_->next(nanoBuffer, numValues, notNull);
+    adjustTimestamp(secsBuffer, nanoBuffer, numValues, notNull);
+  }
+
+  void TimestampColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                           uint64_t numValues,
+                                           std::vector<uint16_t>& skip,
+                                           const std::vector<uint16_t>& next,
+                                           char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    TimestampVectorBatch& timestampBatch = dynamic_cast<TimestampVectorBatch&>(rowBatch);
+    int64_t* secsBuffer = timestampBatch.data.data();
+    int64_t* nanoBuffer = timestampBatch.nanoseconds.data();
+    uint64_t offset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        secondsRle_->skip(static_cast<uint64_t>(skip[i]));
+        nanoRle_->skip(static_cast<uint64_t>(skip[i]));
+      }
+      const uint16_t nextNumValues = next[i];
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      secondsRle_->next(secsBuffer + offset, nextNumValues, parentNotNull);
+      nanoRle_->next(nanoBuffer + offset, nextNumValues, parentNotNull);
+      offset += nextNumValues;
+    }
+    adjustTimestamp(secsBuffer, nanoBuffer, numValues, notNull);
+  }
 
+  void TimestampColumnReader::adjustTimestamp(int64_t* secsBuffer, int64_t* nanoBuffer,
+                                              uint64_t numValues, char* notNull) {
     // Construct the values
     for (uint64_t i = 0; i < numValues; i++) {
       if (notNull == nullptr || notNull[i]) {
@@ -371,6 +509,12 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
 
    private:
@@ -379,6 +523,63 @@ namespace orc {
     const char* bufferPointer_;
     const char* bufferEnd_;
 
+    void skipValues(uint64_t numValues) {
+      if (static_cast<size_t>(bufferEnd_ - bufferPointer_) >= bytesPerValue_ * numValues) {
+        bufferPointer_ += bytesPerValue_ * numValues;
+      } else {
+        size_t sizeToSkip =
+            bytesPerValue_ * numValues - static_cast<size_t>(bufferEnd_ - bufferPointer_);
+        const size_t cap = static_cast<size_t>(std::numeric_limits<int>::max());
+        while (sizeToSkip != 0) {
+          size_t step = sizeToSkip > cap ? cap : sizeToSkip;
+          inputStream_->Skip(static_cast<int>(step));
+          sizeToSkip -= step;
+        }
+        bufferEnd_ = nullptr;
+        bufferPointer_ = nullptr;
+      }
+    }
+
+    void outputDouble(ValueType* outArray, uint64_t numValues, char* notNull) {
+      if constexpr (columnKind == FLOAT) {
+        if (notNull) {
+          for (size_t i = 0; i < numValues; ++i) {
+            if (notNull[i]) {
+              outArray[i] = readFloat<ValueType>();
+            }
+          }
+        } else {
+          for (size_t i = 0; i < numValues; ++i) {
+            outArray[i] = readFloat<ValueType>();
+          }
+        }
+      } else {
+        if (notNull) {
+          for (size_t i = 0; i < numValues; ++i) {
+            if (notNull[i]) {
+              outArray[i] = readDouble<ValueType>();
+            }
+          }
+        } else {
+          // Number of values in the buffer that we can copy directly.
+          // Only viable when the machine is little-endian.
+          uint64_t bufferNum = 0;
+          if (isLittleEndian) {
+            bufferNum = std::min(numValues,
+                                  static_cast<size_t>(bufferEnd_ - bufferPointer_) / bytesPerValue_);
+            uint64_t bufferBytes = bufferNum * bytesPerValue_;
+            if (bufferBytes > 0) {
+              memcpy(outArray, bufferPointer_, bufferBytes);
+              bufferPointer_ += bufferBytes;
+            }
+          }
+          for (size_t i = bufferNum; i < numValues; ++i) {
+            outArray[i] = readDouble<ValueType>();
+          }
+        }
+      }
+    }
+
     unsigned char readByte() {
       if (bufferPointer_ == bufferEnd_) {
         int length;
@@ -454,22 +655,7 @@ namespace orc {
   uint64_t DoubleColumnReader<columnKind, isLittleEndian, ValueType, BatchType>::skip(
       uint64_t numValues) {
     numValues = ColumnReader::skip(numValues);
-
-    if (static_cast<size_t>(bufferEnd_ - bufferPointer_) >= bytesPerValue_ * numValues) {
-      bufferPointer_ += bytesPerValue_ * numValues;
-    } else {
-      size_t sizeToSkip =
-          bytesPerValue_ * numValues - static_cast<size_t>(bufferEnd_ - bufferPointer_);
-      const size_t cap = static_cast<size_t>(std::numeric_limits<int>::max());
-      while (sizeToSkip != 0) {
-        size_t step = sizeToSkip > cap ? cap : sizeToSkip;
-        inputStream_->Skip(static_cast<int>(step));
-        sizeToSkip -= step;
-      }
-      bufferEnd_ = nullptr;
-      bufferPointer_ = nullptr;
-    }
-
+    skipValues(numValues);
     return numValues;
   }
 
@@ -481,43 +667,28 @@ namespace orc {
     notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
     ValueType* outArray =
         reinterpret_cast<ValueType*>(dynamic_cast<BatchType&>(rowBatch).data.data());
+    outputDouble(outArray, numValues, notNull);
+  }
 
-    if constexpr (columnKind == FLOAT) {
-      if (notNull) {
-        for (size_t i = 0; i < numValues; ++i) {
-          if (notNull[i]) {
-            outArray[i] = readFloat<ValueType>();
-          }
-        }
-      } else {
-        for (size_t i = 0; i < numValues; ++i) {
-          outArray[i] = readFloat<ValueType>();
-        }
-      }
-    } else {
-      if (notNull) {
-        for (size_t i = 0; i < numValues; ++i) {
-          if (notNull[i]) {
-            outArray[i] = readDouble<ValueType>();
-          }
-        }
-      } else {
-        // Number of values in the buffer that we can copy directly.
-        // Only viable when the machine is little-endian.
-        uint64_t bufferNum = 0;
-        if (isLittleEndian) {
-          bufferNum = std::min(numValues,
-                               static_cast<size_t>(bufferEnd_ - bufferPointer_) / bytesPerValue_);
-          uint64_t bufferBytes = bufferNum * bytesPerValue_;
-          if (bufferBytes > 0) {
-            memcpy(outArray, bufferPointer_, bufferBytes);
-            bufferPointer_ += bufferBytes;
-          }
-        }
-        for (size_t i = bufferNum; i < numValues; ++i) {
-          outArray[i] = readDouble<ValueType>();
-        }
+  template <TypeKind columnKind, bool isLittleEndian, typename ValueType, typename BatchType>
+  void DoubleColumnReader<columnKind, isLittleEndian, ValueType, BatchType>::nextWithSkip(
+      ColumnVectorBatch& rowBatch,
+      uint64_t numValues,
+      std::vector<uint16_t>& skip,
+      const std::vector<uint16_t>& next,
+      char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    auto* ptr = reinterpret_cast<ValueType*>(dynamic_cast<BatchType&>(rowBatch).data.data());
+    uint64_t offset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        skipValues(static_cast<uint64_t>(skip[i]));
       }
+      uint64_t nextNumValues = next[i];
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      outputDouble(ptr + offset, nextNumValues, parentNotNull);
+      offset += nextNumValues;
     }
   }
 
@@ -562,7 +733,22 @@ namespace orc {
 
     void nextEncoded(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
+    void nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                             uint64_t numValues,
+                             std::vector<uint16_t>& skip,
+                             const std::vector<uint16_t>& next,
+                             char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
+
+   private:
+    void outputString(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull);
   };
 
   StringDictionaryColumnReader::StringDictionaryColumnReader(const Type& type,
@@ -612,17 +798,13 @@ namespace orc {
     return numValues;
   }
 
-  void StringDictionaryColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues,
-                                          char* notNull) {
-    ColumnReader::next(rowBatch, numValues, notNull);
-    // update the notNull from the parent class
-    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+  void StringDictionaryColumnReader::outputString(ColumnVectorBatch& rowBatch,
+                                                  uint64_t numValues, char* notNull) {
     StringVectorBatch& byteBatch = dynamic_cast<StringVectorBatch&>(rowBatch);
     char* blob = dictionary_->dictionaryBlob.data();
     int64_t* dictionaryOffsets = dictionary_->dictionaryOffset.data();
     char** outputStarts = byteBatch.data.data();
     int64_t* outputLengths = byteBatch.length.data();
-    rle_->next(outputLengths, numValues, notNull);
     uint64_t dictionaryCount = dictionary_->dictionaryOffset.size() - 1;
     if (notNull) {
       for (uint64_t i = 0; i < numValues; ++i) {
@@ -647,6 +829,40 @@ namespace orc {
     }
   }
 
+  void StringDictionaryColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues,
+                                          char* notNull) {
+    ColumnReader::next(rowBatch, numValues, notNull);
+    // update the notNull from the parent class
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    StringVectorBatch& byteBatch = dynamic_cast<StringVectorBatch&>(rowBatch);
+    int64_t* outputLengths = byteBatch.length.data();
+    rle_->next(outputLengths, numValues, notNull);
+    outputString(rowBatch, numValues, notNull);
+  }
+
+  void StringDictionaryColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                                  uint64_t numValues,
+                                                  std::vector<uint16_t>& skip,
+                                                  const std::vector<uint16_t>& next,
+                                                  char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    // update the notNull from the parent class
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    StringVectorBatch& byteBatch = dynamic_cast<StringVectorBatch&>(rowBatch);
+    int64_t* outputLengths = byteBatch.length.data();
+    uint64_t offset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        rle_->skip(skip[i]);
+      }
+      uint64_t nextNumValues = next[i];
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      rle_->next(outputLengths + offset, nextNumValues, parentNotNull);
+      offset += nextNumValues;
+    }
+    outputString(rowBatch, numValues, notNull);
+  }
+
   void StringDictionaryColumnReader::nextEncoded(ColumnVectorBatch& rowBatch, uint64_t numValues,
                                                  char* notNull) {
     ColumnReader::next(rowBatch, numValues, notNull);
@@ -660,6 +876,31 @@ namespace orc {
     rle_->next(batch.index.data(), numValues, notNull);
   }
 
+  void StringDictionaryColumnReader::nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                                                          uint64_t numValues,
+                                                          std::vector<uint16_t>& skip,
+                                                          const std::vector<uint16_t>& next,
+                                                          char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    rowBatch.isEncoded = true;
+
+    EncodedStringVectorBatch& batch = dynamic_cast<EncodedStringVectorBatch&>(rowBatch);
+    batch.dictionary = this->dictionary_;
+
+    uint64_t offset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        rle_->skip(skip[i]);
+      }
+      uint64_t nextNumValues = next[i];
+      // Length buffer is reused to save dictionary entry ids
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      rle_->next(batch.index.data() + offset, nextNumValues, parentNotNull);
+      offset += nextNumValues;
+    }
+  }
+
   void StringDictionaryColumnReader::seekToRowGroup(
       std::unordered_map<uint64_t, PositionProvider>& positions) {
     ColumnReader::seekToRowGroup(positions);
@@ -682,6 +923,35 @@ namespace orc {
      */
     size_t computeSize(const int64_t* lengths, const char* notNull, uint64_t numValues);
 
+    /**
+     * Compute the total length of the values.
+     * This function will call lengthRle_->next() to read the lengths.
+     * @param buffer the array of lengths
+     * @param bufferSize the size of the buffer
+     * @param notNull the array of notNull flags
+     * @param numValues the lengths of the arrays
+     * @return the total number of bytes for the non-null values
+     */
+    size_t computeNextSize(int64_t* buffer, const size_t bufferSize,
+                           const char* notNull, uint64_t numValues);
+
+    /**
+     * Skip the given number of values.
+     * @param numValues the number of values to skip
+     */
+    void skipValues(uint64_t numValues);
+
+    /**
+     * Skip the given number of bytes from the blob stream.
+     * @param bytes the number of bytes to skip
+     */
+    void skipBytes(size_t bytes);
+
+    void loadData(char* ptr, size_t totalLength);
+
+    void outputString(char** startPtr, const char* ptr, const int64_t* lengthPtr,
+                      uint64_t numValues, const char* notNull);
+
    public:
     StringDirectColumnReader(const Type& type, StripeStreams& stipe);
     ~StringDirectColumnReader() override;
@@ -690,6 +960,12 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
   };
 
@@ -710,19 +986,15 @@ namespace orc {
     // PASS
   }
 
-  uint64_t StringDirectColumnReader::skip(uint64_t numValues) {
+  void StringDirectColumnReader::skipValues(uint64_t numValues) {
     const size_t BUFFER_SIZE = 1024;
-    numValues = ColumnReader::skip(numValues);
     int64_t buffer[BUFFER_SIZE];
-    uint64_t done = 0;
-    size_t totalBytes = 0;
     // read the lengths, so we know haw many bytes to skip
-    while (done < numValues) {
-      uint64_t step = std::min(BUFFER_SIZE, static_cast<size_t>(numValues - done));
-      lengthRle_->next(buffer, step, nullptr);
-      totalBytes += computeSize(buffer, nullptr, step);
-      done += step;
-    }
+    size_t totalBytes = computeNextSize(buffer, BUFFER_SIZE, nullptr, numValues);
+    skipBytes(totalBytes);
+  }
+
+  void StringDirectColumnReader::skipBytes(size_t totalBytes) {
     if (totalBytes <= lastBufferLength_) {
       // subtract the needed bytes from the ones left over
       lastBufferLength_ -= totalBytes;
@@ -739,6 +1011,11 @@ namespace orc {
       lastBufferLength_ = 0;
       lastBuffer_ = nullptr;
     }
+  }
+
+  uint64_t StringDirectColumnReader::skip(uint64_t numValues) {
+    numValues = ColumnReader::skip(numValues);
+    skipValues(numValues);
     return numValues;
   }
 
@@ -759,26 +1036,45 @@ namespace orc {
     return totalLength;
   }
 
-  void StringDirectColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues,
-                                      char* notNull) {
-    ColumnReader::next(rowBatch, numValues, notNull);
-    // update the notNull from the parent class
-    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
-    StringVectorBatch& byteBatch = dynamic_cast<StringVectorBatch&>(rowBatch);
-    char** startPtr = byteBatch.data.data();
-    int64_t* lengthPtr = byteBatch.length.data();
-
-    // read the length vector
-    lengthRle_->next(lengthPtr, numValues, notNull);
+  size_t StringDirectColumnReader::computeNextSize(int64_t* buffer, const size_t bufferSize,
+                                                   const char* notNull, uint64_t numValues) {
+    uint64_t done = 0;
+    size_t totalBytes = 0;
+    // NOTE: if notNull is not null, need ensure that bufferSize is equal to numValues
+    while (done < numValues) {
+      uint64_t step = std::min(bufferSize, static_cast<size_t>(numValues - done));
+      lengthRle_->next(buffer, step, notNull);
+      totalBytes += computeSize(buffer, notNull, step);
+      done += step;
+    }
+    return totalBytes;
+  }
 
-    // figure out the total length of data we need from the blob stream
-    const size_t totalLength = computeSize(lengthPtr, notNull, numValues);
+  void StringDirectColumnReader::outputString(char** startPtr, const char* ptr,
+                                              const int64_t* lengthPtr, uint64_t numValues,
+                                              const char* notNull) {
+    size_t filledSlots = 0;
+    if (notNull) {
+      while (filledSlots < numValues) {
+        if (notNull[filledSlots]) {
+          startPtr[filledSlots] = const_cast<char*>(ptr);
+          ptr += lengthPtr[filledSlots];
+        }
+        filledSlots += 1;
+      }
+    } else {
+      while (filledSlots < numValues) {
+        startPtr[filledSlots] = const_cast<char*>(ptr);
+        ptr += lengthPtr[filledSlots];
+        filledSlots += 1;
+      }
+    }
+  }
 
+  void StringDirectColumnReader::loadData(char* ptr, size_t totalLength) {
     // Load data from the blob stream into our buffer until we have enough
     // to get the rest directly out of the stream's buffer.
     size_t bytesBuffered = 0;
-    byteBatch.blob.resize(totalLength);
-    char* ptr = byteBatch.blob.data();
     while (bytesBuffered + lastBufferLength_ < totalLength) {
       memcpy(ptr + bytesBuffered, lastBuffer_, lastBufferLength_);
       bytesBuffered += lastBufferLength_;
@@ -797,24 +1093,72 @@ namespace orc {
       lastBuffer_ += moreBytes;
       lastBufferLength_ -= moreBytes;
     }
+  }
 
-    size_t filledSlots = 0;
-    ptr = byteBatch.blob.data();
-    if (notNull) {
-      while (filledSlots < numValues) {
-        if (notNull[filledSlots]) {
-          startPtr[filledSlots] = const_cast<char*>(ptr);
-          ptr += lengthPtr[filledSlots];
-        }
-        filledSlots += 1;
+  void StringDirectColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues,
+                                      char* notNull) {
+    ColumnReader::next(rowBatch, numValues, notNull);
+    // update the notNull from the parent class
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    StringVectorBatch& byteBatch = dynamic_cast<StringVectorBatch&>(rowBatch);
+    char** startPtr = byteBatch.data.data();
+    int64_t* lengthPtr = byteBatch.length.data();
+
+    // read the length vector
+    lengthRle_->next(lengthPtr, numValues, notNull);
+
+    // figure out the total length of data we need from the blob stream
+    const size_t totalLength = computeSize(lengthPtr, notNull, numValues);
+    byteBatch.blob.resize(totalLength);
+    char* ptr = byteBatch.blob.data();
+    loadData(ptr, totalLength);
+    outputString(startPtr, ptr, lengthPtr, numValues, notNull);
+  }
+
+  void StringDirectColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                              uint64_t numValues,
+                                              std::vector<uint16_t>& skip,
+                                              const std::vector<uint16_t>& next,
+                                              char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    // update the notNull from the parent class
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    StringVectorBatch& byteBatch = dynamic_cast<StringVectorBatch&>(rowBatch);
+    char** startPtr = byteBatch.data.data();
+    int64_t* lengthPtr = byteBatch.length.data();
+
+    std::vector<size_t> skipBytes(next.size(), 0);
+    std::vector<size_t> readBytes(next.size(), 0);
+    const size_t BUFFER_SIZE = 1024;
+    int64_t buffer[BUFFER_SIZE];
+    uint64_t offset = 0;
+    size_t totalLength = 0;
+    // compute the bytes to skip and read, and read the length vector
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        skipBytes[i] = computeNextSize(buffer, BUFFER_SIZE, nullptr, skip[i]);
       }
-    } else {
-      while (filledSlots < numValues) {
-        startPtr[filledSlots] = const_cast<char*>(ptr);
-        ptr += lengthPtr[filledSlots];
-        filledSlots += 1;
+      uint64_t nextNumValues = next[i];
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      readBytes[i] = computeNextSize(lengthPtr + offset, nextNumValues,
+                            parentNotNull, nextNumValues);
+      totalLength += readBytes[i];
+      offset += nextNumValues;
+    }
+    byteBatch.blob.resize(totalLength);
+    char* ptr = byteBatch.blob.data();
+    size_t ptrOffset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skipBytes[i] > 0) {
+        StringDirectColumnReader::skipBytes(skipBytes[i]);
+      }
+      const size_t expectedBytes = readBytes[i];
+      if (expectedBytes > 0) {
+        loadData(ptr + ptrOffset, expectedBytes);
+        ptrOffset += expectedBytes;
       }
     }
+    outputString(startPtr, ptr, lengthPtr, numValues, notNull);
   }
 
   void StringDirectColumnReader::seekToRowGroup(
@@ -839,13 +1183,32 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void nextEncoded(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                             uint64_t numValues,
+                             std::vector<uint16_t>& skip,
+                             const std::vector<uint16_t>& next,
+                             char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
 
    private:
     template <bool encoded>
     void nextInternal(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull);
+
+    template <bool encoded>
+    void nextWithSkipInternal(ColumnVectorBatch& rowBatch,
+                              uint64_t numValues,
+                              std::vector<uint16_t>& skip,
+                              const std::vector<uint16_t>& next,
+                              char* notNull);
   };
 
   StructColumnReader::StructColumnReader(const Type& type, StripeStreams& stripe,
@@ -905,6 +1268,44 @@ namespace orc {
     }
   }
 
+  void StructColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                        uint64_t numValues,
+                                        std::vector<uint16_t>& skip,
+                                        const std::vector<uint16_t>& next,
+                                        char* notNull) {
+    nextWithSkipInternal<false>(rowBatch, numValues, skip, next, notNull);
+  }
+
+  void StructColumnReader::nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                                               uint64_t numValues,
+                                               std::vector<uint16_t>& skip,
+                                               const std::vector<uint16_t>& next,
+                                               char* notNull) {
+    nextWithSkipInternal<true>(rowBatch, numValues, skip, next, notNull);
+  }
+
+  template <bool encoded>
+  void StructColumnReader::nextWithSkipInternal(ColumnVectorBatch& rowBatch,
+                                                uint64_t numValues,
+                                                std::vector<uint16_t>& skip,
+                                                const std::vector<uint16_t>& next,
+                                                char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    uint64_t i = 0;
+    for (auto iter = children_.begin(); iter != children_.end(); ++iter, ++i) {
+      // Deep copy the skip vector to avoid modifying the original.
+      std::vector<uint16_t> childSkip(skip);
+      if (encoded) {
+        (*iter)->nextWithSkipEncoded(*(dynamic_cast<StructVectorBatch&>(rowBatch).fields[i]),
+                                     numValues, childSkip, next, notNull);
+      } else {
+        (*iter)->nextWithSkip(*(dynamic_cast<StructVectorBatch&>(rowBatch).fields[i]),
+                              numValues, childSkip, next, notNull);
+      }
+    }
+  }
+
   void StructColumnReader::seekToRowGroup(
       std::unordered_map<uint64_t, PositionProvider>& positions) {
     ColumnReader::seekToRowGroup(positions);
@@ -928,13 +1329,32 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void nextEncoded(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                             uint64_t numValues,
+                             std::vector<uint16_t>& skip,
+                             const std::vector<uint16_t>& next,
+                             char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
 
    private:
     template <bool encoded>
     void nextInternal(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull);
+
+    template <bool encoded>
+    void nextWithSkipInternal(ColumnVectorBatch& rowBatch,
+                              uint64_t numValues,
+                              std::vector<uint16_t>& skip,
+                              const std::vector<uint16_t>& next,
+                              char* notNull);
   };
 
   ListColumnReader::ListColumnReader(const Type& type, StripeStreams& stripe,
@@ -1028,6 +1448,33 @@ namespace orc {
     }
   }
 
+  void ListColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                      uint64_t numValues,
+                                      std::vector<uint16_t>& skip,
+                                      const std::vector<uint16_t>& next,
+                                      char* notNull) {
+    nextWithSkipInternal<false>(rowBatch, numValues, skip, next, notNull);
+  }
+
+  void ListColumnReader::nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                                             uint64_t numValues,
+                                             std::vector<uint16_t>& skip,
+                                             const std::vector<uint16_t>& next,
+                                             char* notNull) {
+    nextWithSkipInternal<true>(rowBatch, numValues, skip, next, notNull);
+  }
+
+  template <bool encoded>
+  void ListColumnReader::nextWithSkipInternal(ColumnVectorBatch& rowBatch,
+                                              uint64_t numValues,
+                                              std::vector<uint16_t>& skip,
+                                              const std::vector<uint16_t>& next,
+                                              char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    // TODO: Implement this.
+    throw NotImplementedYet("ListColumnReader::nextWithSkipInternal is not implemented");
+  }
+
   void ListColumnReader::seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) {
     ColumnReader::seekToRowGroup(positions);
     rle_->seek(positions.at(columnId));
@@ -1051,13 +1498,32 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void nextEncoded(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                             uint64_t numValues,
+                             std::vector<uint16_t>& skip,
+                             const std::vector<uint16_t>& next,
+                             char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
 
    private:
     template <bool encoded>
     void nextInternal(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull);
+
+    template <bool encoded>
+    void nextWithSkipInternal(ColumnVectorBatch& rowBatch,
+                              uint64_t numValues,
+                              std::vector<uint16_t>& skip,
+                              const std::vector<uint16_t>& next,
+                              char* notNull);
   };
 
   MapColumnReader::MapColumnReader(const Type& type, StripeStreams& stripe,
@@ -1169,6 +1635,33 @@ namespace orc {
     }
   }
 
+  void MapColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                     uint64_t numValues,
+                                     std::vector<uint16_t>& skip,
+                                     const std::vector<uint16_t>& next,
+                                     char* notNull) {
+    nextWithSkipInternal<false>(rowBatch, numValues, skip, next, notNull);
+  }
+
+  void MapColumnReader::nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                                            uint64_t numValues,
+                                            std::vector<uint16_t>& skip,
+                                            const std::vector<uint16_t>& next,
+                                            char* notNull) {
+    nextWithSkipInternal<true>(rowBatch, numValues, skip, next, notNull);
+  }
+
+  template <bool encoded>
+  void MapColumnReader::nextWithSkipInternal(ColumnVectorBatch& rowBatch,
+                                             uint64_t numValues,
+                                             std::vector<uint16_t>& skip,
+                                             const std::vector<uint16_t>& next,
+                                             char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    // TODO: Implement this.
+    throw NotImplementedYet("MapColumnReader::nextWithSkipInternal is not implemented");
+  }
+
   void MapColumnReader::seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) {
     ColumnReader::seekToRowGroup(positions);
     rle_->seek(positions.at(columnId));
@@ -1195,13 +1688,32 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void nextEncoded(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                             uint64_t numValues,
+                             std::vector<uint16_t>& skip,
+                             const std::vector<uint16_t>& next,
+                             char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
 
    private:
     template <bool encoded>
     void nextInternal(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull);
+
+    template <bool encoded>
+    void nextWithSkipInternal(ColumnVectorBatch& rowBatch,
+                              uint64_t numValues,
+                              std::vector<uint16_t>& skip,
+                              const std::vector<uint16_t>& next,
+                              char* notNull);
   };
 
   UnionColumnReader::UnionColumnReader(const Type& type, StripeStreams& stripe,
@@ -1296,6 +1808,33 @@ namespace orc {
     }
   }
 
+  void UnionColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                       uint64_t numValues,
+                                       std::vector<uint16_t>& skip,
+                                       const std::vector<uint16_t>& next,
+                                       char* notNull) {
+    nextWithSkipInternal<false>(rowBatch, numValues, skip, next, notNull);
+  }
+
+  void UnionColumnReader::nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                                              uint64_t numValues,
+                                              std::vector<uint16_t>& skip,
+                                              const std::vector<uint16_t>& next,
+                                              char* notNull) {
+    nextWithSkipInternal<true>(rowBatch, numValues, skip, next, notNull);
+  }
+
+  template <bool encoded>
+  void UnionColumnReader::nextWithSkipInternal(ColumnVectorBatch& rowBatch,
+                                               uint64_t numValues,
+                                               std::vector<uint16_t>& skip,
+                                               const std::vector<uint16_t>& next,
+                                               char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    // TODO: Implement this.
+    throw NotImplementedYet("UnionColumnReader::nextWithSkipInternal is not implemented");
+  }
+
   void UnionColumnReader::seekToRowGroup(
       std::unordered_map<uint64_t, PositionProvider>& positions) {
     ColumnReader::seekToRowGroup(positions);
@@ -1372,6 +1911,8 @@ namespace orc {
       }
     }
 
+    void skipValues(uint64_t numValues);
+
    public:
     Decimal64ColumnReader(const Type& type, StripeStreams& stipe);
     ~Decimal64ColumnReader() override;
@@ -1380,7 +1921,16 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
+
+   private:
+    void outputDecimal64(int64_t* values, int64_t* scaleBuffer, uint64_t numValues, char* notNull);
   };
   const uint32_t Decimal64ColumnReader::MAX_PRECISION_64;
   const uint32_t Decimal64ColumnReader::MAX_PRECISION_128;
@@ -1423,8 +1973,7 @@ namespace orc {
     // PASS
   }
 
-  uint64_t Decimal64ColumnReader::skip(uint64_t numValues) {
-    numValues = ColumnReader::skip(numValues);
+  void Decimal64ColumnReader::skipValues(uint64_t numValues) {
     uint64_t skipped = 0;
     while (skipped < numValues) {
       readBuffer();
@@ -1433,9 +1982,30 @@ namespace orc {
       }
     }
     scaleDecoder->skip(numValues);
+  }
+
+  uint64_t Decimal64ColumnReader::skip(uint64_t numValues) {
+    numValues = ColumnReader::skip(numValues);
+    skipValues(numValues);
     return numValues;
   }
 
+  void Decimal64ColumnReader::outputDecimal64(int64_t* values, int64_t* scaleBuffer,
+                                              uint64_t numValues, char* notNull) {
+    if (notNull) {
+      for (uint64_t i = 0; i < numValues; i++) {
+        if (notNull[i]) {
+          readInt64(values[i], static_cast<int32_t>(scaleBuffer[i]));
+        }
+      }
+    } else {
+      for (uint64_t i = 0; i < numValues; i++) {
+        readInt64(values[i], static_cast<int32_t>(scaleBuffer[i]));
+      }
+    }
+  }
+
+
   void Decimal64ColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) {
     ColumnReader::next(rowBatch, numValues, notNull);
     notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
@@ -1446,17 +2016,33 @@ namespace orc {
     scaleDecoder->next(scaleBuffer, numValues, notNull);
     batch.precision = precision;
     batch.scale = scale;
-    if (notNull) {
-      for (size_t i = 0; i < numValues; ++i) {
-        if (notNull[i]) {
-          readInt64(values[i], static_cast<int32_t>(scaleBuffer[i]));
-        }
-      }
-    } else {
-      for (size_t i = 0; i < numValues; ++i) {
-        readInt64(values[i], static_cast<int32_t>(scaleBuffer[i]));
+    outputDecimal64(values, scaleBuffer, numValues, notNull);
+  }
+
+  void Decimal64ColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                           uint64_t numValues,
+                                           std::vector<uint16_t>& skip,
+                                           const std::vector<uint16_t>& next,
+                                           char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    Decimal64VectorBatch& batch = dynamic_cast<Decimal64VectorBatch&>(rowBatch);
+    int64_t* values = batch.values.data();
+    // read the next group of scales
+    int64_t* scaleBuffer = batch.readScales.data();
+    uint64_t offset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        skipValues(static_cast<uint64_t>(skip[i]));
       }
+      uint64_t nextNumValues = next[i];
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      scaleDecoder->next(scaleBuffer + offset, nextNumValues, parentNotNull);
+      outputDecimal64(values + offset, scaleBuffer + offset, nextNumValues, parentNotNull);
+      offset += nextNumValues;
     }
+    batch.precision = precision;
+    batch.scale = scale;
   }
 
   void scaleInt128(Int128& value, uint32_t scale, uint32_t currentScale) {
@@ -1495,6 +2081,12 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
    private:
     void readInt128(Int128& value, int32_t currentScale) {
       value = 0;
@@ -1514,6 +2106,20 @@ namespace orc {
       unZigZagInt128(value);
       scaleInt128(value, static_cast<uint32_t>(scale), static_cast<uint32_t>(currentScale));
     }
+
+    void outputDecimal128(Int128* values, int64_t* scaleBuffer, uint64_t numValues, char* notNull) {
+      if (notNull) {
+        for (size_t i = 0; i < numValues; ++i) {
+          if (notNull[i]) {
+            readInt128(values[i], static_cast<int32_t>(scaleBuffer[i]));
+          }
+        }
+      } else {
+        for (size_t i = 0; i < numValues; ++i) {
+          readInt128(values[i], static_cast<int32_t>(scaleBuffer[i]));
+        }
+      }
+    }
   };
 
   Decimal128ColumnReader::Decimal128ColumnReader(const Type& type, StripeStreams& stripe)
@@ -1536,17 +2142,33 @@ namespace orc {
     scaleDecoder->next(scaleBuffer, numValues, notNull);
     batch.precision = precision;
     batch.scale = scale;
-    if (notNull) {
-      for (size_t i = 0; i < numValues; ++i) {
-        if (notNull[i]) {
-          readInt128(values[i], static_cast<int32_t>(scaleBuffer[i]));
-        }
-      }
-    } else {
-      for (size_t i = 0; i < numValues; ++i) {
-        readInt128(values[i], static_cast<int32_t>(scaleBuffer[i]));
+    outputDecimal128(values, scaleBuffer, numValues, notNull);
+  }
+
+  void Decimal128ColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                            uint64_t numValues,
+                                            std::vector<uint16_t>& skip,
+                                            const std::vector<uint16_t>& next,
+                                            char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    Decimal128VectorBatch& batch = dynamic_cast<Decimal128VectorBatch&>(rowBatch);
+    Int128* values = batch.values.data();
+    // read the next group of scales
+    int64_t* scaleBuffer = batch.readScales.data();
+    uint64_t offset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        skipValues(static_cast<uint64_t>(skip[i]));
       }
+      uint64_t nextNumValues = next[i];
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      scaleDecoder->next(scaleBuffer + offset, nextNumValues, parentNotNull);
+      outputDecimal128(values + offset, scaleBuffer + offset, nextNumValues, parentNotNull);
+      offset += nextNumValues;
     }
+    batch.precision = precision;
+    batch.scale = scale;
   }
 
   class Decimal64ColumnReaderV2 : public ColumnReader {
@@ -1562,6 +2184,12 @@ namespace orc {
     uint64_t skip(uint64_t numValues) override;
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
   };
 
   Decimal64ColumnReaderV2::Decimal64ColumnReaderV2(const Type& type, StripeStreams& stripe)
@@ -1598,6 +2226,29 @@ namespace orc {
     batch.scale = scale;
   }
 
+
+  void Decimal64ColumnReaderV2::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                             uint64_t numValues,
+                                             std::vector<uint16_t>& skip,
+                                             const std::vector<uint16_t>& next,
+                                             char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    Decimal64VectorBatch& batch = dynamic_cast<Decimal64VectorBatch&>(rowBatch);
+    uint64_t offset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        valueDecoder->skip(static_cast<uint64_t>(skip[i]));
+      }
+      uint64_t nextNumValues = next[i];
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      valueDecoder->next(batch.values.data() + offset, nextNumValues, parentNotNull);
+      offset += nextNumValues;
+    }
+    batch.precision = precision;
+    batch.scale = scale;
+  }
+
   class DecimalHive11ColumnReader : public Decimal64ColumnReader {
    private:
     bool throwOnOverflow_;
@@ -1640,11 +2291,20 @@ namespace orc {
       return value >= MIN_VALUE && value <= MAX_VALUE;
     }
 
+    void outputDecimal128(ColumnVectorBatch& rowBatch, Int128* values, int64_t* scaleBuffer,
+                          uint64_t numValues, char* notNull);
+
    public:
     DecimalHive11ColumnReader(const Type& type, StripeStreams& stipe);
     ~DecimalHive11ColumnReader() override;
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
   };
 
   DecimalHive11ColumnReader::DecimalHive11ColumnReader(const Type& type, StripeStreams& stripe)
@@ -1658,19 +2318,10 @@ namespace orc {
     // PASS
   }
 
-  void DecimalHive11ColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues,
-                                       char* notNull) {
-    ColumnReader::next(rowBatch, numValues, notNull);
-    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+  void DecimalHive11ColumnReader::outputDecimal128(ColumnVectorBatch& rowBatch,
+                                                    Int128* values, int64_t* scaleBuffer,
+                                                    uint64_t numValues, char* notNull) {
     Decimal128VectorBatch& batch = dynamic_cast<Decimal128VectorBatch&>(rowBatch);
-    Int128* values = batch.values.data();
-    // read the next group of scales
-    int64_t* scaleBuffer = batch.readScales.data();
-
-    scaleDecoder->next(scaleBuffer, numValues, notNull);
-
-    batch.precision = precision;
-    batch.scale = scale;
     if (notNull) {
       for (size_t i = 0; i < numValues; ++i) {
         if (notNull[i]) {
@@ -1703,6 +2354,47 @@ namespace orc {
     }
   }
 
+  void DecimalHive11ColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues,
+                                       char* notNull) {
+    ColumnReader::next(rowBatch, numValues, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    Decimal128VectorBatch& batch = dynamic_cast<Decimal128VectorBatch&>(rowBatch);
+    Int128* values = batch.values.data();
+    // read the next group of scales
+    int64_t* scaleBuffer = batch.readScales.data();
+
+    scaleDecoder->next(scaleBuffer, numValues, notNull);
+    outputDecimal128(rowBatch, values, scaleBuffer, numValues, notNull);
+    batch.precision = precision;
+    batch.scale = scale;
+  }
+
+  void DecimalHive11ColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                               uint64_t numValues,
+                                               std::vector<uint16_t>& skip,
+                                               const std::vector<uint16_t>& next,
+                                               char* notNull) {
+    ColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    notNull = rowBatch.hasNulls ? rowBatch.notNull.data() : nullptr;
+    Decimal128VectorBatch& batch = dynamic_cast<Decimal128VectorBatch&>(rowBatch);
+    Int128* values = batch.values.data();
+    // read the next group of scales
+    int64_t* scaleBuffer = batch.readScales.data();
+    uint64_t offset = 0;
+    for (uint64_t i = 0; i < next.size(); i++) {
+      if (skip[i] > 0) {
+        skipValues(static_cast<uint64_t>(skip[i]));
+      }
+      uint64_t nextNumValues = next[i];
+      char* parentNotNull = notNull ? notNull + offset : nullptr;
+      scaleDecoder->next(scaleBuffer + offset, nextNumValues, parentNotNull);
+      outputDecimal128(rowBatch, values + offset, scaleBuffer + offset, nextNumValues, parentNotNull);
+      offset += nextNumValues;
+    }
+    batch.precision = precision;
+    batch.scale = scale;
+  }
+
   static bool isLittleEndian() {
     static union {
       uint32_t i;
diff --git a/c++/src/ColumnReader.hh b/c++/src/ColumnReader.hh
index f0f3fe1b..c1c76ce9 100644
--- a/c++/src/ColumnReader.hh
+++ b/c++/src/ColumnReader.hh
@@ -155,6 +155,41 @@ namespace orc {
       next(rowBatch, numValues, notNull);
     }
 
+    /**
+     * Read the next group of values with skip bitmap.
+     * @param rowBatch the memory to read into.
+     * @param numValues the number of values to read
+     * @param skip the number of values to skip
+     * @param next the number of values to read
+     * @param notNull if null, all values are not null. Otherwise, it is
+     *           a mask (with at least numValues bytes) for which values to
+     *           set.
+     */
+    virtual void nextWithSkip(ColumnVectorBatch& rowBatch,
+                              uint64_t numValues,
+                              std::vector<uint16_t>& skip,
+                              const std::vector<uint16_t>& next,
+                              char* notNull);
+
+    /**
+     * Read the next group of values with skip bitmap and values without decoding.
+     * @param rowBatch the memory to read into.
+     * @param numValues the number of values to read
+     * @param skip the number of values to skip
+     * @param next the number of values to read
+     * @param notNull if null, all values are not null. Otherwise, it is
+     *           a mask (with at least numValues bytes) for which values to
+     *           set.
+     */
+    virtual void nextWithSkipEncoded(ColumnVectorBatch& rowBatch,
+                                     uint64_t numValues,
+                                     std::vector<uint16_t>& skip,
+                                     const std::vector<uint16_t>& next,
+                                     char* notNull) {
+      rowBatch.isEncoded = true;
+      nextWithSkip(rowBatch, numValues, skip, next, notNull);
+    }
+
     /**
      * Seek to beginning of a row group in the current stripe
      * @param positions a list of PositionProviders storing the positions
diff --git a/c++/src/ConvertColumnReader.cc b/c++/src/ConvertColumnReader.cc
index a9003bc1..d64a6c34 100644
--- a/c++/src/ConvertColumnReader.cc
+++ b/c++/src/ConvertColumnReader.cc
@@ -37,6 +37,19 @@ namespace orc {
 
   void ConvertColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) {
     reader->next(*data, numValues, notNull);
+    convertInternal(rowBatch);
+  }
+
+  void ConvertColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                         uint64_t numValues,
+                                         std::vector<uint16_t>& skip,
+                                         const std::vector<uint16_t>& next,
+                                         char* notNull) {
+    reader->nextWithSkip(*data, numValues, skip, next, notNull);
+    convertInternal(rowBatch);
+  }
+
+  void ConvertColumnReader::convertInternal(ColumnVectorBatch& rowBatch) {
     rowBatch.resize(data->capacity);
     rowBatch.numElements = data->numElements;
     rowBatch.hasNulls = data->hasNulls;
@@ -161,6 +174,20 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
+
+   private:
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const FileTypeBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<ReadTypeBatch*>(&rowBatch);
       if (rowBatch.hasNulls) {
@@ -190,6 +217,20 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
+
+   private:
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const FileTypeBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<BooleanVectorBatch*>(&rowBatch);
       if (rowBatch.hasNulls) {
@@ -212,26 +253,38 @@ namespace orc {
                                        StripeStreams& stripe, bool throwOnOverflow)
         : ConvertColumnReader(readType, fileType, stripe, throwOnOverflow) {}
 
-    void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
+    void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
+      ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
 
     virtual uint64_t convertToStrBuffer(ColumnVectorBatch& rowBatch, uint64_t numValues) = 0;
 
+   private:
+    void convertInternal(ColumnVectorBatch& rowBatch);
+
    protected:
     std::vector<std::string> strBuffer;
   };
 
-  void ConvertToStringVariantColumnReader::next(ColumnVectorBatch& rowBatch, uint64_t numValues,
-                                                char* notNull) {
-    ConvertColumnReader::next(rowBatch, numValues, notNull);
-
+  void ConvertToStringVariantColumnReader::convertInternal(ColumnVectorBatch& rowBatch) {
     // cache converted string in the buffer
-    auto totalLength = convertToStrBuffer(rowBatch, numValues);
+    auto totalLength = convertToStrBuffer(rowBatch, data->numElements);
 
     // contact string values to blob buffer of vector batch
     auto& dstBatch = *SafeCastBatchTo<StringVectorBatch*>(&rowBatch);
     dstBatch.blob.resize(totalLength);
     char* blob = dstBatch.blob.data();
-    for (uint64_t i = 0; i < numValues; ++i) {
+    for (uint64_t i = 0; i < data->numElements; ++i) {
       if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
         const auto size = strBuffer[i].size();
         ::memcpy(blob, strBuffer[i].c_str(), size);
@@ -352,12 +405,25 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
+
+   private:
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const FileTypeBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<ReadTypeBatch*>(&rowBatch);
       dstBatch.precision = precision_;
       dstBatch.scale = scale_;
-      for (uint64_t i = 0; i < numValues; ++i) {
+      for (uint64_t i = 0; i < data->numElements; ++i) {
         if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
           if constexpr (isFloatingFileType) {
             convertDoubleToDecimal(dstBatch, i, srcBatch.data[i]);
@@ -368,7 +434,6 @@ namespace orc {
       }
     }
 
-   private:
     template <typename SrcType>
     void convertDoubleToDecimal(ReadTypeBatch& dstBatch, uint64_t idx, SrcType value) {
       const auto result = convertDecimal(value, precision_, scale_);
@@ -425,6 +490,12 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
    protected:
     const bool isInstant;
     const orc::Timezone* readerTimezone;
@@ -437,6 +508,14 @@ namespace orc {
     ConvertColumnReader::next(rowBatch, numValues, notNull);
   }
 
+  void ConvertToTimestampColumnReader::nextWithSkip(ColumnVectorBatch& rowBatch,
+                                                    uint64_t numValues,
+                                                    std::vector<uint16_t>& skip,
+                                                    const std::vector<uint16_t>& next,
+                                                    char* notNull) {
+    ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+  }
+
   template <typename FileTypeBatch>
   class NumericToTimestampColumnReader : public ConvertToTimestampColumnReader {
    public:
@@ -446,17 +525,29 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertToTimestampColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertToTimestampColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
 
+   private:
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const FileTypeBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<TimestampVectorBatch*>(&rowBatch);
-      for (uint64_t i = 0; i < numValues; ++i) {
+      for (uint64_t i = 0; i < data->numElements; ++i) {
         if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
           convertToTimestamp(dstBatch, i, srcBatch.data[i]);
         }
       }
     }
 
-   private:
     template <typename FileType>
     void convertToTimestamp(TimestampVectorBatch& dstBatch, uint64_t idx, FileType value);
   };
@@ -503,10 +594,22 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
 
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const FileTypeBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<ReadTypeBatch*>(&rowBatch);
-      for (uint64_t i = 0; i < numValues; ++i) {
+      for (uint64_t i = 0; i < data->numElements; ++i) {
         if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
           if constexpr (std::is_floating_point_v<ReadType>) {
             convertDecimalToDouble(dstBatch, i, srcBatch);
@@ -551,10 +654,22 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
 
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const FileTypeBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<BooleanVectorBatch*>(&rowBatch);
-      for (uint64_t i = 0; i < numValues; ++i) {
+      for (uint64_t i = 0; i < data->numElements; ++i) {
         if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
           dstBatch.data[i] = srcBatch.values[i] == 0 ? 0 : 1;
         }
@@ -576,10 +691,22 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
 
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const FileTypeBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<ReadTypeBatch*>(&rowBatch);
-      for (uint64_t i = 0; i < numValues; ++i) {
+      for (uint64_t i = 0; i < data->numElements; ++i) {
         if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
           convertDecimalToDecimal(dstBatch, i, srcBatch);
         }
@@ -625,6 +752,19 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const FileTypeBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<TimestampVectorBatch*>(&rowBatch);
       for (uint64_t i = 0; i < rowBatch.numElements; ++i) {
@@ -724,10 +864,22 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
 
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const StringVectorBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<ReadTypeBatch*>(&rowBatch);
-      for (uint64_t i = 0; i < numValues; ++i) {
+      for (uint64_t i = 0; i < data->numElements; ++i) {
         if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
           if constexpr (std::is_floating_point_v<ReadType>) {
             convertToDouble(dstBatch, srcBatch, i);
@@ -832,11 +984,23 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertToTimestampColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertToTimestampColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
 
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const StringVectorBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<TimestampVectorBatch*>(&rowBatch);
 
-      for (uint64_t i = 0; i < numValues; ++i) {
+      for (uint64_t i = 0; i < data->numElements; ++i) {
         if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
           convertToTimestamp(dstBatch, i, std::string(srcBatch.data[i], srcBatch.length[i]));
         }
@@ -937,10 +1101,22 @@ namespace orc {
 
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override {
       ConvertColumnReader::next(rowBatch, numValues, notNull);
+      convertInternal(rowBatch);
+    }
+
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override {
+      ConvertColumnReader::nextWithSkip(rowBatch, numValues, skip, next, notNull);
+      convertInternal(rowBatch);
+    }
 
+    void convertInternal(ColumnVectorBatch& rowBatch) {
       const auto& srcBatch = *SafeCastBatchTo<const StringVectorBatch*>(data.get());
       auto& dstBatch = *SafeCastBatchTo<ReadTypeBatch*>(&rowBatch);
-      for (uint64_t i = 0; i < numValues; ++i) {
+      for (uint64_t i = 0; i < data->numElements; ++i) {
         if (!rowBatch.hasNulls || rowBatch.notNull[i]) {
           convertToDecimal(dstBatch, i, std::string(srcBatch.data[i], srcBatch.length[i]));
         }
diff --git a/c++/src/ConvertColumnReader.hh b/c++/src/ConvertColumnReader.hh
index 6ed4d017..58161980 100644
--- a/c++/src/ConvertColumnReader.hh
+++ b/c++/src/ConvertColumnReader.hh
@@ -32,6 +32,13 @@ namespace orc {
     // override next() to implement convert logic
     void next(ColumnVectorBatch& rowBatch, uint64_t numValues, char* notNull) override;
 
+    // override nextWithSkip() to implement convert logic
+    void nextWithSkip(ColumnVectorBatch& rowBatch,
+                      uint64_t numValues,
+                      std::vector<uint16_t>& skip,
+                      const std::vector<uint16_t>& next,
+                      char* notNull) override;
+
     uint64_t skip(uint64_t numValues) override;
 
     void seekToRowGroup(std::unordered_map<uint64_t, PositionProvider>& positions) override;
@@ -42,6 +49,9 @@ namespace orc {
     std::unique_ptr<ColumnReader> reader;
     std::unique_ptr<ColumnVectorBatch> data;
     const bool throwOnOverflow;
+
+   private:
+    void convertInternal(ColumnVectorBatch& rowBatch);
   };
 
   std::unique_ptr<ColumnReader> buildConvertReader(const Type& fileType, StripeStreams& stripe,
diff --git a/c++/src/RLEv2.hh b/c++/src/RLEv2.hh
index 8ceb7f12..05e80780 100644
--- a/c++/src/RLEv2.hh
+++ b/c++/src/RLEv2.hh
@@ -159,7 +159,7 @@ namespace orc {
     /**
      * Read a number of values into the batch.
      */
-    template <typename T>
+    template <typename T, bool needCopyData>
     void next(T* data, uint64_t numValues, const char* notNull);
 
     void next(int64_t* data, uint64_t numValues, const char* notNull) override;
@@ -240,13 +240,13 @@ namespace orc {
     uint64_t readVulong();
     void readLongs(int64_t* data, uint64_t offset, uint64_t len, uint64_t fbs);
 
-    template <typename T>
+    template <typename T, bool needCopyData>
     uint64_t nextShortRepeats(T* data, uint64_t offset, uint64_t numValues, const char* notNull);
-    template <typename T>
+    template <typename T, bool needCopyData>
     uint64_t nextDirect(T* data, uint64_t offset, uint64_t numValues, const char* notNull);
-    template <typename T>
+    template <typename T, bool needCopyData>
     uint64_t nextPatched(T* data, uint64_t offset, uint64_t numValues, const char* notNull);
-    template <typename T>
+    template <typename T, bool needCopyData>
     uint64_t nextDelta(T* data, uint64_t offset, uint64_t numValues, const char* notNull);
     template <typename T>
     uint64_t copyDataFromBuffer(T* data, uint64_t offset, uint64_t numValues, const char* notNull);
diff --git a/c++/src/Reader.cc b/c++/src/Reader.cc
index c93c62f6..4d7c27cd 100644
--- a/c++/src/Reader.cc
+++ b/c++/src/Reader.cc
@@ -246,7 +246,8 @@ namespace orc {
     buildTypeNameIdMap(contents_->schema.get());
   }
 
-  RowReaderImpl::RowReaderImpl(std::shared_ptr<FileContents> contents, const RowReaderOptions& opts)
+  RowReaderImpl::RowReaderImpl(std::shared_ptr<FileContents> contents, const RowReaderOptions& opts,
+                               CachedReaderContext* cachedReaderContext)
       : localTimezone_(getLocalTimezone()),
         contents_(contents),
         throwOnHive11DecimalOverflow_(opts.getThrowOnHive11DecimalOverflow()),
@@ -255,7 +256,8 @@ namespace orc {
         firstRowOfStripe_(*contents_->pool, 0),
         enableEncodedBlock_(opts.getEnableLazyDecoding()),
         readerTimezone_(getTimezoneByName(opts.getTimezoneName())),
-        schemaEvolution_(opts.getReadType(), contents_->schema.get()) {
+        schemaEvolution_(opts.getReadType(), contents_->schema.get()),
+        cachedReaderContext_(cachedReaderContext) {
     uint64_t numberOfStripes;
     numberOfStripes = static_cast<uint64_t>(footer_->stripes_size());
     currentStripe_ = numberOfStripes;
@@ -311,6 +313,11 @@ namespace orc {
     }
 
     skipBloomFilters_ = hasBadBloomFilters();
+
+    // set row indexes to shared stripe context for other row readers to reuse
+    if (cachedReaderContext_ != nullptr) {
+      cachedReaderContext_->rowIndexes = &rowIndexes_;
+    }
   }
 
   // Check if the file has inconsistent bloom filters.
@@ -420,7 +427,7 @@ namespace orc {
     uint64_t rowsToSkip = currentRowInStripe_;
     // seek to the target row group if row indexes exists
     if (rowIndexStride > 0 && currentStripeInfo_.index_length() > 0) {
-      if (rowIndexes_.empty()) {
+      if (!hasCachedRowIndexes() && rowIndexes_.empty()) {
         loadStripeIndex();
       }
       // TODO(ORC-1175): process the failures of loadStripeIndex() call
@@ -484,9 +491,15 @@ namespace orc {
     std::list<std::list<uint64_t>> positions;
     // store position providers for selected colimns
     std::unordered_map<uint64_t, PositionProvider> positionProviders;
+    const std::unordered_map<uint64_t, proto::RowIndex>* rowIndexes = hasCachedRowIndexes() ?
+        static_cast<std::unordered_map<uint64_t, proto::RowIndex>*>(cachedReaderContext_->rowIndexes)
+        : &rowIndexes_;
 
-    for (auto rowIndex = rowIndexes_.cbegin(); rowIndex != rowIndexes_.cend(); ++rowIndex) {
+    for (auto rowIndex = rowIndexes->cbegin(); rowIndex != rowIndexes->cend(); ++rowIndex) {
       uint64_t colId = rowIndex->first;
+      if (!selectedColumns_[colId]) {
+        continue;
+      }
       const proto::RowIndexEntry& entry =
           rowIndex->second.entry(static_cast<int32_t>(rowGroupEntryId));
 
@@ -547,7 +560,8 @@ namespace orc {
         options_(opts),
         fileLength_(fileLength),
         postscriptLength_(postscriptLength),
-        footer_(contents_->footer.get()) {
+        footer_(contents_->footer.get()),
+        cachedReaderContext_(nullptr) {
     isMetadataLoaded_ = false;
     checkOrcVersion();
     numberOfStripes_ = static_cast<uint64_t>(footer_->stripes_size());
@@ -700,15 +714,25 @@ namespace orc {
   void ReaderImpl::getRowIndexStatistics(
       const proto::StripeInformation& stripeInfo, uint64_t stripeIndex,
       const proto::StripeFooter& currentStripeFooter,
+      const bool* selectedColumns,
       std::vector<std::vector<proto::ColumnStatistics>>* indexStats) const {
     int num_streams = currentStripeFooter.streams_size();
     uint64_t offset = stripeInfo.offset();
     uint64_t indexEnd = stripeInfo.offset() + stripeInfo.index_length();
+    std::unordered_map<uint64_t, proto::RowIndex>* rowIndexes = nullptr;
+    if (cachedReaderContext_ != nullptr && cachedReaderContext_->rowIndexes != nullptr) {
+      // clear the last stripe's row indexes
+      rowIndexes = static_cast<std::unordered_map<uint64_t, proto::RowIndex>*>(
+          cachedReaderContext_->rowIndexes);
+      rowIndexes->clear();
+    }
     for (int i = 0; i < num_streams; i++) {
       const proto::Stream& stream = currentStripeFooter.streams(i);
       StreamKind streamKind = static_cast<StreamKind>(stream.kind());
       uint64_t length = static_cast<uint64_t>(stream.length());
-      if (streamKind == StreamKind::StreamKind_ROW_INDEX) {
+      uint64_t colId = stream.column();
+      if (streamKind == StreamKind::StreamKind_ROW_INDEX &&
+          (selectedColumns == nullptr || selectedColumns[colId])) {
         if (offset + length > indexEnd) {
           std::stringstream msg;
           msg << "Malformed RowIndex stream meta in stripe " << stripeIndex
@@ -727,6 +751,10 @@ namespace orc {
         if (!rowIndex.ParseFromZeroCopyStream(pbStream.get())) {
           throw ParseError("Failed to parse RowIndex from stripe footer");
         }
+        // store row indexes for selected columns
+        if (rowIndexes != nullptr) {
+          (*rowIndexes)[colId] = rowIndex;
+        }
         int num_entries = rowIndex.entry_size();
         size_t column = static_cast<size_t>(stream.column());
         for (int j = 0; j < num_entries; j++) {
@@ -751,27 +779,58 @@ namespace orc {
     return *(contents_->schema.get());
   }
 
-  std::unique_ptr<StripeStatistics> ReaderImpl::getStripeStatistics(uint64_t stripeIndex) const {
+  std::unique_ptr<StripeStatistics> ReaderImpl::getStripeStatistics(
+      uint64_t stripeIndex,
+      bool includeRowIndex,
+      const bool* selectedColumns) const {
     if (!isMetadataLoaded_) {
       readMetadata();
     }
     if (contents_->metadata == nullptr) {
       throw std::logic_error("No stripe statistics in file");
     }
-    size_t num_cols = static_cast<size_t>(
-        contents_->metadata->stripe_stats(static_cast<int>(stripeIndex)).col_stats_size());
-    std::vector<std::vector<proto::ColumnStatistics>> indexStats(num_cols);
 
     proto::StripeInformation currentStripeInfo = footer_->stripes(static_cast<int>(stripeIndex));
-    proto::StripeFooter currentStripeFooter = getStripeFooter(currentStripeInfo, *contents_.get());
-
-    getRowIndexStatistics(currentStripeInfo, stripeIndex, currentStripeFooter, &indexStats);
+    if (cachedReaderContext_ != nullptr) {
+      StripeInformationImpl* stripeInfo =
+          dynamic_cast<StripeInformationImpl*>(cachedReaderContext_->currentStripeInfo.get());
+      if (stripeInfo == nullptr) {
+        throw std::logic_error("stripe info is not a StripeInformationImpl");
+      }
+      const proto::StripeFooter* currentStripeFooter = stripeInfo->getStripeFooter();
+      return getStripeStatistics(stripeIndex, currentStripeInfo,
+                                 *currentStripeFooter, includeRowIndex, selectedColumns);
+    } else {
+      proto::StripeFooter currentStripeFooter = getStripeFooter(currentStripeInfo, *contents_.get());
+      return getStripeStatistics(stripeIndex, currentStripeInfo, currentStripeFooter, includeRowIndex,
+                                 selectedColumns);
+    }
+  }
 
+  std::unique_ptr<StripeStatistics> ReaderImpl::getStripeStatistics(
+      uint64_t stripeIndex,
+      const proto::StripeInformation& currentStripeInfo,
+      const proto::StripeFooter& currentStripeFooter,
+      bool includeRowIndex,
+      const bool* selectedColumns) const {
     const Timezone& writerTZ = currentStripeFooter.has_writer_timezone()
                                    ? getTimezoneByName(currentStripeFooter.writer_timezone())
                                    : getLocalTimezone();
     StatContext statContext(hasCorrectStatistics(), &writerTZ);
-    return std::make_unique<StripeStatisticsImpl>(
+
+    if (!includeRowIndex) {
+      return std::make_unique<StripeStatisticsImpl>(
+          contents_->metadata->stripe_stats(static_cast<int>(stripeIndex)), statContext);
+    }
+
+    size_t num_cols = static_cast<size_t>(
+        contents_->metadata->stripe_stats(static_cast<int>(stripeIndex)).col_stats_size());
+    std::vector<std::vector<proto::ColumnStatistics>> indexStats(num_cols);
+
+    getRowIndexStatistics(currentStripeInfo, stripeIndex, currentStripeFooter, selectedColumns,
+                          &indexStats);
+
+    return std::make_unique<StripeStatisticsWithRowGroupIndexImpl>(
         contents_->metadata->stripe_stats(static_cast<int>(stripeIndex)), indexStats, statContext);
   }
 
@@ -838,7 +897,7 @@ namespace orc {
       // load stripe statistics for PPD
       readMetadata();
     }
-    return std::make_unique<RowReaderImpl>(contents_, opts);
+    return std::make_unique<RowReaderImpl>(contents_, opts, cachedReaderContext_);
   }
 
   uint64_t maxStreamsForType(const proto::Type& type) {
@@ -1024,7 +1083,9 @@ namespace orc {
 
   void RowReaderImpl::startNextStripe() {
     reader_.reset();  // ColumnReaders use lots of memory; free old memory first
-    rowIndexes_.clear();
+    if (!hasCachedRowIndexes()) {
+      rowIndexes_.clear();
+    }
     bloomFilterIndex_.clear();
 
     // evaluate file statistics if it exists
@@ -1066,8 +1127,20 @@ namespace orc {
       }
 
       if (isStripeNeeded) {
-        currentStripeFooter_ = getStripeFooter(currentStripeInfo_, *contents_.get());
+        if (cachedReaderContext_ != nullptr) {
+          StripeInformationImpl* stripeInfo =
+              dynamic_cast<StripeInformationImpl*>(cachedReaderContext_->currentStripeInfo.get());
+          if (stripeInfo == nullptr) {
+            throw std::logic_error("stripe info is not a StripeInformationImpl");
+          }
+          currentStripeFooter_ = *stripeInfo->getStripeFooter();
+        } else {
+          currentStripeFooter_ = getStripeFooter(currentStripeInfo_, *contents_.get());
+        }
         if (sargsApplier_) {
+          if (cachedReaderContext_ != nullptr) {
+            throw std::logic_error("cached reader context is not supported when PPD is enabled");
+          }
           // read row group statistics and bloom filters of current stripe
           loadStripeIndex();
 
@@ -1168,6 +1241,39 @@ namespace orc {
     return rowsToRead != 0;
   }
 
+  bool RowReaderImpl::next(ColumnVectorBatch& data, const ProjectArgument& arg) {
+    SCOPED_STOPWATCH(contents_->readerMetrics, ReaderInclusiveLatencyUs, ReaderCall);
+    if (currentStripe_ >= lastStripe_) {
+      data.numElements = 0;
+      markEndOfFile();
+      return false;
+    }
+    if (currentRowInStripe_ == 0) {
+      startNextStripe();
+    }
+    if (rowsInCurrentStripe_ - currentRowInStripe_ < arg.numRead) {
+      throw ParseError("numRead is greater than the number of rows in the current stripe");
+    }
+    data.numElements = arg.numValues;
+
+    std::vector<uint16_t> skip(arg.skip, arg.skip + arg.size);
+    std::vector<uint16_t> next(arg.next, arg.next + arg.size);
+    if (enableEncodedBlock_) {
+      reader_->nextWithSkipEncoded(data, arg.numValues, skip, next, nullptr);
+    } else {
+      reader_->nextWithSkip(data, arg.numValues, skip, next, nullptr);
+    }
+    // update row number
+    previousRow_ = firstRowOfStripe_[currentStripe_] + currentRowInStripe_;
+    currentRowInStripe_ += arg.numRead;
+
+    if (currentRowInStripe_ >= rowsInCurrentStripe_) {
+      currentStripe_ += 1;
+      currentRowInStripe_ = 0;
+    }
+    return arg.numRead != 0;
+  }
+
   uint64_t RowReaderImpl::computeBatchSize(uint64_t requestedSize, uint64_t currentRowInStripe,
                                            uint64_t rowsInCurrentStripe, uint64_t rowIndexStride,
                                            const std::vector<uint64_t>& nextSkippedRows) {
diff --git a/c++/src/Reader.hh b/c++/src/Reader.hh
index 39ca7396..c9bbae40 100644
--- a/c++/src/Reader.hh
+++ b/c++/src/Reader.hh
@@ -183,6 +183,13 @@ namespace orc {
     // match read and file types
     SchemaEvolution schemaEvolution_;
 
+    // cached reader context
+    CachedReaderContext* cachedReaderContext_;
+
+    inline bool hasCachedRowIndexes() const {
+      return cachedReaderContext_ != nullptr && cachedReaderContext_->rowIndexes != nullptr;
+    }
+
     // load stripe index if not done so
     void loadStripeIndex();
 
@@ -224,8 +231,10 @@ namespace orc {
      * Constructor that lets the user specify additional options.
      * @param contents of the file
      * @param options options for reading
+     * @param cachedReaderContext the cached reader context
      */
-    RowReaderImpl(std::shared_ptr<FileContents> contents, const RowReaderOptions& options);
+    RowReaderImpl(std::shared_ptr<FileContents> contents, const RowReaderOptions& options,
+                  CachedReaderContext* cachedReaderContext);
 
     // Select the columns from the options object
     const std::vector<bool> getSelectedColumns() const override;
@@ -236,6 +245,8 @@ namespace orc {
 
     bool next(ColumnVectorBatch& data) override;
 
+    bool next(ColumnVectorBatch& data, const ProjectArgument& arg) override;
+
     CompressionKind getCompression() const;
 
     uint64_t getCompressionSize() const;
@@ -272,6 +283,9 @@ namespace orc {
     proto::Footer* footer_;
     uint64_t numberOfStripes_;
 
+    // cached reader context
+    CachedReaderContext* cachedReaderContext_;
+
     uint64_t getMemoryUse(int stripeIx, std::vector<bool>& selectedColumns);
 
     // internal methods
@@ -279,8 +293,15 @@ namespace orc {
     void checkOrcVersion();
     void getRowIndexStatistics(const proto::StripeInformation& stripeInfo, uint64_t stripeIndex,
                                const proto::StripeFooter& currentStripeFooter,
+                               const bool* selectedColumns,
                                std::vector<std::vector<proto::ColumnStatistics>>* indexStats) const;
     proto::StripeFooter loadCurrentStripeFooter(uint32_t stripeIndex, uint64_t& offset) const;
+    std::unique_ptr<StripeStatistics> getStripeStatistics(
+        uint64_t stripeIndex,
+        const proto::StripeInformation& currentStripeInfo,
+        const proto::StripeFooter& currentStripeFooter,
+        bool includeRowIndex,
+        const bool* selectedColumns) const;
 
     // metadata
     mutable bool isMetadataLoaded_;
@@ -330,7 +351,10 @@ namespace orc {
 
     const std::string& getStreamName() const override;
 
-    std::unique_ptr<StripeStatistics> getStripeStatistics(uint64_t stripeIndex) const override;
+    std::unique_ptr<StripeStatistics> getStripeStatistics(
+        uint64_t stripeIndex,
+        bool includeRowIndex = true,
+        const bool* selectedColumns = nullptr) const override;
 
     std::unique_ptr<RowReader> createRowReader() const override;
 
@@ -393,6 +417,10 @@ namespace orc {
 
     std::map<uint32_t, RowGroupIndex> getRowGroupIndex(
         uint32_t stripeIndex, const std::set<uint32_t>& included) const override;
+
+    void setCachedReaderContext(CachedReaderContext* context) override {
+      cachedReaderContext_ = context;
+    }
   };
 }  // namespace orc
 
diff --git a/c++/src/RleDecoderV2.cc b/c++/src/RleDecoderV2.cc
index f35dd4fe..b7c7483c 100644
--- a/c++/src/RleDecoderV2.cc
+++ b/c++/src/RleDecoderV2.cc
@@ -119,17 +119,11 @@ namespace orc {
   void RleDecoderV2::skip(uint64_t numValues) {
     // simple for now, until perf tests indicate something encoding specific is
     // needed
-    const uint64_t N = 64;
-    int64_t dummy[N];
-
-    while (numValues) {
-      uint64_t nRead = std::min(N, numValues);
-      next(dummy, nRead, nullptr);
-      numValues -= nRead;
-    }
+    int64_t* dummy = nullptr;
+    next<int64_t, false>(dummy, numValues, nullptr);
   }
 
-  template <typename T>
+  template <typename T, bool needCopyData>
   void RleDecoderV2::next(T* const data, const uint64_t numValues, const char* const notNull) {
     SCOPED_STOPWATCH(metrics, DecodingLatencyUs, DecodingCall);
     uint64_t nRead = 0;
@@ -152,16 +146,16 @@ namespace orc {
       EncodingType enc = static_cast<EncodingType>((firstByte_ >> 6) & 0x03);
       switch (static_cast<int64_t>(enc)) {
         case SHORT_REPEAT:
-          nRead += nextShortRepeats(data, offset, length, notNull);
+          nRead += nextShortRepeats<T, needCopyData>(data, offset, length, notNull);
           break;
         case DIRECT:
-          nRead += nextDirect(data, offset, length, notNull);
+          nRead += nextDirect<T, needCopyData>(data, offset, length, notNull);
           break;
         case PATCHED_BASE:
-          nRead += nextPatched(data, offset, length, notNull);
+          nRead += nextPatched<T, needCopyData>(data, offset, length, notNull);
           break;
         case DELTA:
-          nRead += nextDelta(data, offset, length, notNull);
+          nRead += nextDelta<T, needCopyData>(data, offset, length, notNull);
           break;
         default:
           throw ParseError("unknown encoding");
@@ -170,18 +164,18 @@ namespace orc {
   }
 
   void RleDecoderV2::next(int64_t* data, uint64_t numValues, const char* notNull) {
-    next<int64_t>(data, numValues, notNull);
+    next<int64_t, true>(data, numValues, notNull);
   }
 
   void RleDecoderV2::next(int32_t* data, uint64_t numValues, const char* notNull) {
-    next<int32_t>(data, numValues, notNull);
+    next<int32_t, true>(data, numValues, notNull);
   }
 
   void RleDecoderV2::next(int16_t* data, uint64_t numValues, const char* notNull) {
-    next<int16_t>(data, numValues, notNull);
+    next<int16_t, true>(data, numValues, notNull);
   }
 
-  template <typename T>
+  template <typename T, bool needCopyData>
   uint64_t RleDecoderV2::nextShortRepeats(T* const data, uint64_t offset, uint64_t numValues,
                                           const char* const notNull) {
     if (runRead_ == runLength_) {
@@ -203,25 +197,29 @@ namespace orc {
     }
 
     uint64_t nRead = std::min(runLength_ - runRead_, numValues);
-
-    if (notNull) {
-      for (uint64_t pos = offset; pos < offset + nRead; ++pos) {
-        if (notNull[pos]) {
+    if (needCopyData) {
+      if (notNull) {
+        for (uint64_t pos = offset; pos < offset + nRead; ++pos) {
+          if (notNull[pos]) {
+            data[pos] = static_cast<T>(literals_[0]);
+            ++runRead_;
+          }
+        }
+      } else {
+        for (uint64_t pos = offset; pos < offset + nRead; ++pos) {
           data[pos] = static_cast<T>(literals_[0]);
           ++runRead_;
         }
       }
     } else {
-      for (uint64_t pos = offset; pos < offset + nRead; ++pos) {
-        data[pos] = static_cast<T>(literals_[0]);
-        ++runRead_;
-      }
+      // if we don't need to copy data, just increment the runRead_ counter
+      runRead_ += nRead;
     }
 
     return nRead;
   }
 
-  template <typename T>
+  template <typename T, bool needCopyData>
   uint64_t RleDecoderV2::nextDirect(T* const data, uint64_t offset, uint64_t numValues,
                                     const char* const notNull) {
     if (runRead_ == runLength_) {
@@ -243,8 +241,14 @@ namespace orc {
         }
       }
     }
-
-    return copyDataFromBuffer(data, offset, numValues, notNull);
+    uint64_t nRead = 0;
+    if (needCopyData) {
+      nRead = copyDataFromBuffer(data, offset, numValues, notNull);
+    } else {
+      nRead = std::min(runLength_ - runRead_, numValues);
+      runRead_ += nRead;
+    }
+    return nRead;
   }
 
   void RleDecoderV2::adjustGapAndPatch(uint32_t patchBitSize, int64_t patchMask, int64_t* resGap,
@@ -270,7 +274,7 @@ namespace orc {
     *patchIdx = idx;
   }
 
-  template <typename T>
+  template <typename T, bool needCopyData>
   uint64_t RleDecoderV2::nextPatched(T* const data, uint64_t offset, uint64_t numValues,
                                      const char* const notNull) {
     if (runRead_ == runLength_) {
@@ -366,10 +370,17 @@ namespace orc {
       }
     }
 
-    return copyDataFromBuffer(data, offset, numValues, notNull);
+    uint64_t nRead = 0;
+    if (needCopyData) {
+      nRead = copyDataFromBuffer(data, offset, numValues, notNull);
+    } else {
+      nRead = std::min(runLength_ - runRead_, numValues);
+      runRead_ += nRead;
+    }
+    return nRead;
   }
 
-  template <typename T>
+  template <typename T, bool needCopyData>
   uint64_t RleDecoderV2::nextDelta(T* const data, uint64_t offset, uint64_t numValues,
                                    const char* const notNull) {
     if (runRead_ == runLength_) {
@@ -431,7 +442,14 @@ namespace orc {
       }
     }
 
-    return copyDataFromBuffer(data, offset, numValues, notNull);
+    uint64_t nRead = 0;
+    if (needCopyData) {
+      nRead = copyDataFromBuffer(data, offset, numValues, notNull);
+    } else {
+      nRead = std::min(runLength_ - runRead_, numValues);
+      runRead_ += nRead;
+    }
+    return nRead;
   }
 
   template <typename T>
diff --git a/c++/src/Statistics.cc b/c++/src/Statistics.cc
index 76fd736b..c1a23cad 100644
--- a/c++/src/Statistics.cc
+++ b/c++/src/Statistics.cc
@@ -81,11 +81,20 @@ namespace orc {
     // PASS
   }
 
-  StripeStatisticsImpl::StripeStatisticsImpl(
+  StripeStatisticsImpl::StripeStatisticsImpl(const proto::StripeStatistics& stripeStats,
+                                             const StatContext& statContext) {
+    columnStats_ = std::make_unique<StatisticsImpl>(stripeStats, statContext);
+  }
+
+  StripeStatisticsWithRowGroupIndexImpl::~StripeStatisticsWithRowGroupIndexImpl() {
+    // PASS
+  }
+
+  StripeStatisticsWithRowGroupIndexImpl::StripeStatisticsWithRowGroupIndexImpl(
       const proto::StripeStatistics& stripeStats,
       std::vector<std::vector<proto::ColumnStatistics> >& indexStats,
-      const StatContext& statContext) {
-    columnStats_ = std::make_unique<StatisticsImpl>(stripeStats, statContext);
+      const StatContext& statContext)
+      : StripeStatisticsImpl(stripeStats, statContext) {
     rowIndexStats_.resize(indexStats.size());
     for (size_t i = 0; i < rowIndexStats_.size(); i++) {
       for (size_t j = 0; j < indexStats[i].size(); j++) {
diff --git a/c++/src/Statistics.hh b/c++/src/Statistics.hh
index 6f212c15..b7ed5d1e 100644
--- a/c++/src/Statistics.hh
+++ b/c++/src/Statistics.hh
@@ -1713,7 +1713,6 @@ namespace orc {
   class StripeStatisticsImpl : public StripeStatistics {
    private:
     std::unique_ptr<StatisticsImpl> columnStats_;
-    std::vector<std::vector<std::shared_ptr<const ColumnStatistics> > > rowIndexStats_;
 
     // DELIBERATELY NOT IMPLEMENTED
     StripeStatisticsImpl(const StripeStatisticsImpl&);
@@ -1721,7 +1720,6 @@ namespace orc {
 
    public:
     StripeStatisticsImpl(const proto::StripeStatistics& stripeStats,
-                         std::vector<std::vector<proto::ColumnStatistics> >& indexStats,
                          const StatContext& statContext);
 
     virtual const ColumnStatistics* getColumnStatistics(uint32_t columnId) const override {
@@ -1732,13 +1730,38 @@ namespace orc {
       return columnStats_->getNumberOfColumns();
     }
 
+    virtual const ColumnStatistics* getRowIndexStatistics(uint32_t, uint32_t) const override {
+      throw NotImplementedYet("set includeRowIndex true to get row index stats");
+    }
+
+    virtual ~StripeStatisticsImpl() override;
+
+    virtual uint32_t getNumberOfRowIndexStats(uint32_t) const override {
+      throw NotImplementedYet("set includeRowIndex true to get row index stats");
+    }
+  };
+
+  class StripeStatisticsWithRowGroupIndexImpl : public StripeStatisticsImpl {
+   private:
+    std::vector<std::vector<std::shared_ptr<const ColumnStatistics> > > rowIndexStats_;
+
+    // DELIBERATELY NOT IMPLEMENTED
+    StripeStatisticsWithRowGroupIndexImpl(const StripeStatisticsWithRowGroupIndexImpl&);
+    StripeStatisticsWithRowGroupIndexImpl& operator=(const StripeStatisticsWithRowGroupIndexImpl&);
+
+   public:
+    StripeStatisticsWithRowGroupIndexImpl(
+        const proto::StripeStatistics& stripeStats,
+        std::vector<std::vector<proto::ColumnStatistics> >& indexStats,
+        const StatContext& statContext);
+
     virtual const ColumnStatistics* getRowIndexStatistics(uint32_t columnId,
                                                           uint32_t rowIndex) const override {
       // check id indices are valid
       return rowIndexStats_[columnId][rowIndex].get();
     }
 
-    virtual ~StripeStatisticsImpl() override;
+    virtual ~StripeStatisticsWithRowGroupIndexImpl() override;
 
     uint32_t getNumberOfRowIndexStats(uint32_t columnId) const override {
       return static_cast<uint32_t>(rowIndexStats_[columnId].size());
diff --git a/c++/src/StripeStream.hh b/c++/src/StripeStream.hh
index 2d26f857..d30f2e87 100644
--- a/c++/src/StripeStream.hh
+++ b/c++/src/StripeStream.hh
@@ -208,6 +208,11 @@ namespace orc {
       ensureStripeFooterLoaded();
       return stripeFooter_->writer_timezone();
     }
+
+    const proto::StripeFooter* getStripeFooter() const {
+      ensureStripeFooterLoaded();
+      return stripeFooter_.get();
+    }
   };
 
 }  // namespace orc
diff --git a/c++/test/TestStripeIndexStatistics.cc b/c++/test/TestStripeIndexStatistics.cc
index 85fdb80e..a529792c 100644
--- a/c++/test/TestStripeIndexStatistics.cc
+++ b/c++/test/TestStripeIndexStatistics.cc
@@ -83,6 +83,31 @@ namespace orc {
         "length: "
         "8000\n",
         stringColStats->toString());
+
+    std::unique_ptr<orc::Statistics> stripeLevelStats = reader->getStripeStatistics(0, false);
+    const orc::IntegerColumnStatistics* stripeLevelIntColStats;
+    stripeLevelIntColStats = reinterpret_cast<const orc::IntegerColumnStatistics*>(
+        stripeLevelStats->getColumnStatistics(1));
+    EXPECT_EQ(
+        "Data type: Integer\nValues: 6000\nHas null: yes\nMinimum: 1\nMaximum: 6000\nSum: "
+        "18003000\n",
+        stripeLevelIntColStats->toString());
+
+    const orc::StringColumnStatistics* stripeLevelStringColStats;
+    stripeLevelStringColStats = reinterpret_cast<const orc::StringColumnStatistics*>(
+        stripeLevelStats->getColumnStatistics(2));
+    EXPECT_EQ(
+        "Data type: String\nValues: 6000\nHas null: yes\nMinimum: 1000\nMaximum: 9a\nTotal length: "
+        "23892\n",
+        stripeLevelStringColStats->toString());
+
+    intColStats =
+        reinterpret_cast<const orc::IntegerColumnStatistics*>(stripeStats->getColumnStatistics(1));
+    stringColStats =
+        reinterpret_cast<const orc::StringColumnStatistics*>(stripeStats->getColumnStatistics(2));
+
+    EXPECT_EQ(intColStats->toString(), stripeLevelIntColStats->toString());
+    EXPECT_EQ(stringColStats->toString(), stripeLevelStringColStats->toString());
   }
 
 }  // namespace orc
diff --git a/c++/test/TestTimestampStatistics.cc b/c++/test/TestTimestampStatistics.cc
index d20a0495..e005fa6c 100644
--- a/c++/test/TestTimestampStatistics.cc
+++ b/c++/test/TestTimestampStatistics.cc
@@ -68,6 +68,19 @@ namespace orc {
         "00:00:00.688\nLowerBound: 1995-01-01 00:00:00.688\nMaximum: 2037-01-01 "
         "00:00:00.0\nUpperBound: 2037-01-01 00:00:00.1\n",
         stripeColStats->toString());
+
+    std::unique_ptr<orc::StripeStatistics> stripeStatsWithOutRowIndex =
+        reader->getStripeStatistics(0, false);
+    const orc::TimestampColumnStatistics* stripeColStatsOnly =
+        reinterpret_cast<const orc::TimestampColumnStatistics*>(
+            stripeStatsWithOutRowIndex->getColumnStatistics(0));
+
+    EXPECT_TRUE(stripeColStatsOnly->hasMinimum());
+    EXPECT_TRUE(stripeColStatsOnly->hasMaximum());
+    EXPECT_EQ(stripeColStats->toString(), stripeColStatsOnly->toString());
+    EXPECT_EQ(stripeStats->getNumberOfColumns(), stripeStatsWithOutRowIndex->getNumberOfColumns());
+    EXPECT_THROW(stripeStatsWithOutRowIndex->getRowIndexStatistics(1, 1), NotImplementedYet);
+    EXPECT_THROW(stripeStatsWithOutRowIndex->getNumberOfRowIndexStats(1), NotImplementedYet);
   }
 
   TEST(TestTimestampStatistics, testTimezoneUTC) {
