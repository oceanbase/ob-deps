diff --git a/cpp/cmake_modules/ThirdpartyToolchain.cmake b/cpp/cmake_modules/ThirdpartyToolchain.cmake
index 63bdd4ab76..756243a634 100644
--- a/cpp/cmake_modules/ThirdpartyToolchain.cmake
+++ b/cpp/cmake_modules/ThirdpartyToolchain.cmake
@@ -1420,8 +1420,24 @@
     # This can be removed once CRAN no longer checks on macOS 10.13
     find_program(PATCH patch REQUIRED)
     set(SNAPPY_PATCH_COMMAND ${PATCH} -p1 -i ${CMAKE_CURRENT_LIST_DIR}/snappy.diff)
+    message(STATUS "+++++++++++++++++++++++++Looking for snappy patch at: ${CMAKE_SOURCE_DIR}")
+  elseif(APPLE)
+    set(SNAPPY_PATCH_FILE "/Users/admin/huaixin.lmy/ob-deps/patch/snappy-1.2.2.patch")
+    if(EXISTS "${SNAPPY_PATCH_FILE}")
+      find_program(PATCH patch REQUIRED)
+      set(SNAPPY_PATCH_COMMAND ${PATCH} -p1 -i ${SNAPPY_PATCH_FILE})
+      message(STATUS "Found snappy patch file: ${SNAPPY_PATCH_FILE}")
+    endif()
   else()
-    set(SNAPPY_PATCH_COMMAND)
+    message(STATUS "+++++++++++++++++++++++++Looking for snappy patch at: ${CMAKE_SOURCE_DIR}")
+    set(SNAPPY_PATCH_FILE "${CMAKE_SOURCE_DIR}/../../patch/snappy-1.2.2.patch")
+    if(EXISTS "${SNAPPY_PATCH_FILE}")
+      find_program(PATCH patch REQUIRED)
+      set(SNAPPY_PATCH_COMMAND ${PATCH} -p1 -i ${SNAPPY_PATCH_FILE})
+      message(STATUS "Found snappy patch file: ${SNAPPY_PATCH_FILE}")
+    else()
+      set(SNAPPY_PATCH_COMMAND)
+    endif()
   endif()
 
   if(CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
# diff --git a/cpp/src/arrow/util/compression_snappy.cc b/cpp/src/arrow/util/compression_snappy.cc
# index 731fdfd133..3fb305a447 100644
# --- a/cpp/src/arrow/util/compression_snappy.cc
# +++ b/cpp/src/arrow/util/compression_snappy.cc
# @@ -44,7 +44,7 @@ class SnappyCodec : public Codec {
#    Result<int64_t> Decompress(int64_t input_len, const uint8_t* input,
#                               int64_t output_buffer_len, uint8_t* output_buffer) override {
#      size_t decompressed_size;
# -    if (!snappy::GetUncompressedLength(reinterpret_cast<const char*>(input),
# +    if (!snappy_1_2_2::GetUncompressedLength(reinterpret_cast<const char*>(input),
#                                         static_cast<size_t>(input_len),
#                                         &decompressed_size)) {
#        return Status::IOError("Corrupt snappy compressed data.");
# @@ -53,7 +53,7 @@ class SnappyCodec : public Codec {
#        return Status::Invalid("Output buffer size (", output_buffer_len, ") must be ",
#                               decompressed_size, " or larger.");
#      }
# -    if (!snappy::RawUncompress(reinterpret_cast<const char*>(input),
# +    if (!snappy_1_2_2::RawUncompress(reinterpret_cast<const char*>(input),
#                                 static_cast<size_t>(input_len),
#                                 reinterpret_cast<char*>(output_buffer))) {
#        return Status::IOError("Corrupt snappy compressed data.");
# @@ -64,14 +64,14 @@ class SnappyCodec : public Codec {
#    int64_t MaxCompressedLen(int64_t input_len,
#                             const uint8_t* ARROW_ARG_UNUSED(input)) override {
#      DCHECK_GE(input_len, 0);
# -    return snappy::MaxCompressedLength(static_cast<size_t>(input_len));
# +    return snappy_1_2_2::MaxCompressedLength(static_cast<size_t>(input_len));
#    }
 
#    Result<int64_t> Compress(int64_t input_len, const uint8_t* input,
#                             int64_t ARROW_ARG_UNUSED(output_buffer_len),
#                             uint8_t* output_buffer) override {
#      size_t output_size;
# -    snappy::RawCompress(reinterpret_cast<const char*>(input),
# +    snappy_1_2_2::RawCompress(reinterpret_cast<const char*>(input),
#                          static_cast<size_t>(input_len),
#                          reinterpret_cast<char*>(output_buffer), &output_size);
#      return static_cast<int64_t>(output_size);


